Starting new log file Wed Jul  2 16:52:17 2025

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running yosys for verilog parsing and synthesis
yosys  -s aluuu.ys

/----------------------------------------------------------------------------\
|                                                                            |
|  yosys -- Yosys Open SYnthesis Suite                                       |
|                                                                            |
|  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
|                                                                            |
|  Permission to use, copy, modify, and/or distribute this software for any  |
|  purpose with or without fee is hereby granted, provided that the above    |
|  copyright notice and this permission notice appear in all copies.         |
|                                                                            |
|  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
|  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
|  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
|  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
|  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
|  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
|  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
|                                                                            |
\----------------------------------------------------------------------------/

Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `aluuu.ys' --

1. Executing Liberty frontend: /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
Imported 39 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/kor-tac/Desktop/physical/alu/source/aluuu.v
Parsing Verilog input from `/home/kor-tac/Desktop/physical/alu/source/aluuu.v' to AST representation.
Generating RTLIL representation for module `\ha'.
Generating RTLIL representation for module `\fa1'.
Generating RTLIL representation for module `\multi_10'.
/home/kor-tac/Desktop/physical/alu/source/aluuu.v:41: Warning: Identifier `\p' is implicitly declared.
Generating RTLIL representation for module `\adder_10'.
Generating RTLIL representation for module `\sub_10'.
Generating RTLIL representation for module `\comp_10'.
Generating RTLIL representation for module `\adie'.
Generating RTLIL representation for module `\orie'.
Generating RTLIL representation for module `\arilef'.
Generating RTLIL representation for module `\aririi'.
Generating RTLIL representation for module `\aluuu'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10

3.1.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10
Removed 0 unused modules.
Mapping positional arguments of cell aluuu.aR1 (aririi).
Mapping positional arguments of cell aluuu.aL1 (arilef).
Mapping positional arguments of cell aluuu.on (orie).
Mapping positional arguments of cell aluuu.an (adie).
Mapping positional arguments of cell aluuu.c1 (comp_10).
Mapping positional arguments of cell aluuu.ss1 (sub_10).
Mapping positional arguments of cell aluuu.a1 (adder_10).
Mapping positional arguments of cell aluuu.m1 (multi_10).
Mapping positional arguments of cell sub_10.f9 (fa1).
Mapping positional arguments of cell sub_10.f8 (fa1).
Mapping positional arguments of cell sub_10.f7 (fa1).
Mapping positional arguments of cell sub_10.f6 (fa1).
Mapping positional arguments of cell sub_10.f5 (fa1).
Mapping positional arguments of cell sub_10.f4 (fa1).
Mapping positional arguments of cell sub_10.f3 (fa1).
Mapping positional arguments of cell sub_10.f2 (fa1).
Mapping positional arguments of cell sub_10.f1 (fa1).
Mapping positional arguments of cell sub_10.f0 (fa1).
Mapping positional arguments of cell adder_10.f9 (fa1).
Mapping positional arguments of cell adder_10.f8 (fa1).
Mapping positional arguments of cell adder_10.f7 (fa1).
Mapping positional arguments of cell adder_10.f6 (fa1).
Mapping positional arguments of cell adder_10.f5 (fa1).
Mapping positional arguments of cell adder_10.f4 (fa1).
Mapping positional arguments of cell adder_10.f3 (fa1).
Mapping positional arguments of cell adder_10.f2 (fa1).
Mapping positional arguments of cell adder_10.f1 (fa1).
Mapping positional arguments of cell adder_10.f0 (fa1).
Mapping positional arguments of cell multi_10.h18 (fa1).
Mapping positional arguments of cell multi_10.f74 (fa1).
Mapping positional arguments of cell multi_10.f73 (fa1).
Mapping positional arguments of cell multi_10.f72 (fa1).
Mapping positional arguments of cell multi_10.f71 (fa1).
Mapping positional arguments of cell multi_10.f70 (fa1).
Mapping positional arguments of cell multi_10.f69 (fa1).
Mapping positional arguments of cell multi_10.f68 (fa1).
Mapping positional arguments of cell multi_10.f67 (fa1).
Mapping positional arguments of cell multi_10.h17 (ha).
Mapping positional arguments of cell multi_10.h16 (fa1).
Mapping positional arguments of cell multi_10.f66 (fa1).
Mapping positional arguments of cell multi_10.f65 (fa1).
Mapping positional arguments of cell multi_10.f64 (fa1).
Mapping positional arguments of cell multi_10.f63 (fa1).
Mapping positional arguments of cell multi_10.f62 (fa1).
Mapping positional arguments of cell multi_10.f61 (fa1).
Mapping positional arguments of cell multi_10.f60 (fa1).
Mapping positional arguments of cell multi_10.f59 (fa1).
Mapping positional arguments of cell multi_10.h15 (ha).
Mapping positional arguments of cell multi_10.h14 (fa1).
Mapping positional arguments of cell multi_10.f58 (fa1).
Mapping positional arguments of cell multi_10.f57 (fa1).
Mapping positional arguments of cell multi_10.f56 (fa1).
Mapping positional arguments of cell multi_10.f53 (fa1).
Mapping positional arguments of cell multi_10.f52 (fa1).
Mapping positional arguments of cell multi_10.f51 (fa1).
Mapping positional arguments of cell multi_10.f50 (fa1).
Mapping positional arguments of cell multi_10.f49 (fa1).
Mapping positional arguments of cell multi_10.h13 (ha).
Mapping positional arguments of cell multi_10.h12 (fa1).
Mapping positional arguments of cell multi_10.f48 (fa1).
Mapping positional arguments of cell multi_10.f47 (fa1).
Mapping positional arguments of cell multi_10.f46 (fa1).
Mapping positional arguments of cell multi_10.f45 (fa1).
Mapping positional arguments of cell multi_10.f44 (fa1).
Mapping positional arguments of cell multi_10.f43 (fa1).
Mapping positional arguments of cell multi_10.f42 (fa1).
Mapping positional arguments of cell multi_10.f41 (fa1).
Mapping positional arguments of cell multi_10.h11 (ha).
Mapping positional arguments of cell multi_10.h10 (fa1).
Mapping positional arguments of cell multi_10.f40 (fa1).
Mapping positional arguments of cell multi_10.f39 (fa1).
Mapping positional arguments of cell multi_10.f38 (fa1).
Mapping positional arguments of cell multi_10.f37 (fa1).
Mapping positional arguments of cell multi_10.f36 (fa1).
Mapping positional arguments of cell multi_10.f35 (fa1).
Mapping positional arguments of cell multi_10.f34 (fa1).
Mapping positional arguments of cell multi_10.f33 (fa1).
Mapping positional arguments of cell multi_10.h9 (ha).
Mapping positional arguments of cell multi_10.h8 (fa1).
Mapping positional arguments of cell multi_10.f32 (fa1).
Mapping positional arguments of cell multi_10.f31 (fa1).
Mapping positional arguments of cell multi_10.f30 (fa1).
Mapping positional arguments of cell multi_10.f29 (fa1).
Mapping positional arguments of cell multi_10.f28 (fa1).
Mapping positional arguments of cell multi_10.f27 (fa1).
Mapping positional arguments of cell multi_10.f26 (fa1).
Mapping positional arguments of cell multi_10.f25 (fa1).
Mapping positional arguments of cell multi_10.h7 (ha).
Mapping positional arguments of cell multi_10.h6 (fa1).
Mapping positional arguments of cell multi_10.f24 (fa1).
Mapping positional arguments of cell multi_10.f23 (fa1).
Mapping positional arguments of cell multi_10.f22 (fa1).
Mapping positional arguments of cell multi_10.f21 (fa1).
Mapping positional arguments of cell multi_10.f20 (fa1).
Mapping positional arguments of cell multi_10.f19 (fa1).
Mapping positional arguments of cell multi_10.f18 (fa1).
Mapping positional arguments of cell multi_10.f17 (fa1).
Mapping positional arguments of cell multi_10.h5 (ha).
Mapping positional arguments of cell multi_10.h4 (fa1).
Mapping positional arguments of cell multi_10.f16 (fa1).
Mapping positional arguments of cell multi_10.f15 (fa1).
Mapping positional arguments of cell multi_10.f14 (fa1).
Mapping positional arguments of cell multi_10.f13 (fa1).
Mapping positional arguments of cell multi_10.f12 (fa1).
Mapping positional arguments of cell multi_10.f11 (fa1).
Mapping positional arguments of cell multi_10.f10 (fa1).
Mapping positional arguments of cell multi_10.f9 (fa1).
Mapping positional arguments of cell multi_10.h3 (ha).
Mapping positional arguments of cell multi_10.h2 (ha).
Mapping positional arguments of cell multi_10.f8 (fa1).
Mapping positional arguments of cell multi_10.f7 (fa1).
Mapping positional arguments of cell multi_10.f6 (fa1).
Mapping positional arguments of cell multi_10.f5 (fa1).
Mapping positional arguments of cell multi_10.f4 (fa1).
Mapping positional arguments of cell multi_10.f3 (fa1).
Mapping positional arguments of cell multi_10.f2 (fa1).
Mapping positional arguments of cell multi_10.f1 (fa1).
Mapping positional arguments of cell multi_10.h1 (ha).
Mapping positional arguments of cell fa1.h2 (ha).
Mapping positional arguments of cell fa1.h1 (ha).
Warning: Resizing cell port aluuu.a1.sum from 10 bits to 11 bits.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed 1 dead cases from process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Marked 1 switch rules as full_case in process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Removed a total of 1 dead cases.

3.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

3.2.4. Executing PROC_INIT pass (extract init attributes).

3.2.5. Executing PROC_ARST pass (detect async resets in processes).

3.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~1 debug messages>

3.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
1/1: $1\y[19:0]

3.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\aluuu.\y' from process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.

3.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Removing empty process `aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Cleaned up 1 empty switch.

3.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module aririi.
<suppressed ~1 debug messages>
Optimizing module arilef.
<suppressed ~1 debug messages>
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
<suppressed ~1 debug messages>
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
Optimizing module aririi.
Optimizing module arilef.
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \sub_10..
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Removed 0 unused cells and 16 unused wires.
<suppressed ~10 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
<suppressed ~486 debug messages>
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 162 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.6. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 162 unused wires.
<suppressed ~1 debug messages>

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.16. Finished OPT passes. (There is nothing left to do.)

3.7. Executing FSM pass (extract and optimize FSM).

3.7.1. Executing FSM_DETECT pass (finding FSMs in design).

3.7.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.7.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.7.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.7.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.7.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.8. Executing OPT pass (performing simple optimizations).

3.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.6. Executing OPT_DFF pass (perform DFF optimizations).

3.8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.9. Finished OPT passes. (There is nothing left to do.)

3.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$373_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$374_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell aluuu.$procmux$375_CMP0 ($eq).

3.10. Executing PEEPOPT pass (run peephole optimizers).

3.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.12. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module adder_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module adie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aluuu:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arilef:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aririi:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module comp_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module fa1:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module ha:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module multi_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module orie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module sub_10:
created 0 $alu and 0 $macc cells.

3.13. Executing SHARE pass (SAT-based resource sharing).

3.14. Executing OPT pass (performing simple optimizations).

3.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.6. Executing OPT_DFF pass (perform DFF optimizations).

3.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.9. Finished OPT passes. (There is nothing left to do.)

3.15. Executing MEMORY pass.

3.15.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.15.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.15.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.15.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.15.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.15.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.15.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.15.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.17. Executing OPT pass (performing simple optimizations).

3.17.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.17.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.17.3. Executing OPT_DFF pass (perform DFF optimizations).

3.17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

3.17.5. Finished fast OPT passes.

3.18. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

3.19. Executing OPT pass (performing simple optimizations).

3.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.6. Executing OPT_SHARE pass.

3.19.7. Executing OPT_DFF pass (perform DFF optimizations).

3.19.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.19.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.10. Finished OPT passes. (There is nothing left to do.)

3.20. Executing TECHMAP pass (map to technology primitives).

3.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.20.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $xnor.
Using extmapper simplemap for cells of type $eq.
Using template $paramod$43fa60c46e83442767389184ae02572e3838275f\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $mux.
No more expansions possible.
<suppressed ~324 debug messages>

3.21. Executing OPT pass (performing simple optimizations).

3.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~153 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
<suppressed ~36 debug messages>
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 12 cells.

3.21.3. Executing OPT_DFF pass (perform DFF optimizations).

3.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 125 unused wires.
<suppressed ~1 debug messages>

3.21.5. Finished fast OPT passes.

3.22. Executing ABC pass (technology mapping using ABC).

3.22.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.2.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 175 gates and 263 wires to a netlist network with 87 inputs and 20 outputs.

3.22.3.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.3.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:              NAND cells:        3
ABC RESULTS:                OR cells:       61
ABC RESULTS:               MUX cells:       10
ABC RESULTS:             ORNOT cells:       14
ABC RESULTS:            ANDNOT cells:       77
ABC RESULTS:        internal signals:      156
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

3.22.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 95 gates and 115 wires to a netlist network with 20 inputs and 3 outputs.

3.22.6.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.6.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       10
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:       18
ABC RESULTS:            ANDNOT cells:       20
ABC RESULTS:                OR cells:       44
ABC RESULTS:        internal signals:       92
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

3.22.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

3.22.7.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.7.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

3.22.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

3.22.8.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.8.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

3.22.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

3.22.9.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

3.22.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.10.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.10.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.

3.22.11.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.11.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:       10
Removing temp directory.

3.23. Executing OPT pass (performing simple optimizations).

3.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.23.3. Executing OPT_DFF pass (perform DFF optimizations).

3.23.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 469 unused wires.
<suppressed ~8 debug messages>

3.23.5. Finished fast OPT passes.

3.24. Executing HIERARCHY pass (managing design hierarchy).

3.24.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10

3.24.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10
Removed 0 unused modules.

3.25. Printing statistics.

=== adder_10 ===

Number of wires:                  4
Number of wire bits:             40
Number of public wires:           4
Number of public wire bits:      40
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
fa1                            10

=== adie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_AND_                         10

=== aluuu ===

Number of wires:                160
Number of wire bits:            275
Number of public wires:          12
Number of public wire bits:     127
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                175
$_ANDNOT_                      77
$_AND_                          1
$_MUX_                         10
$_NAND_                         3
$_NOT_                          1
$_ORNOT_                       14
$_OR_                          61
adder_10                        1
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
orie                            1
sub_10                          1

=== arilef ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== aririi ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== comp_10 ===

Number of wires:                 93
Number of wire bits:            113
Number of public wires:           3
Number of public wire bits:      23
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 93
$_ANDNOT_                      20
$_NOR_                          1
$_NOT_                         18
$_OR_                          44
$_XOR_                         10

=== fa1 ===

Number of wires:                  8
Number of wire bits:              8
Number of public wires:           8
Number of public wire bits:       8
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  3
$_OR_                           1
ha                              2

=== ha ===

Number of wires:                  4
Number of wire bits:              4
Number of public wires:           4
Number of public wire bits:       4
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  2
$_AND_                          1
$_XOR_                          1

=== multi_10 ===

Number of wires:                264
Number of wire bits:            301
Number of public wires:         165
Number of public wire bits:     202
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                190
$_AND_                        100
fa1                            80
ha                             10

=== orie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_OR_                          10

=== sub_10 ===

Number of wires:                  5
Number of wire bits:             51
Number of public wires:           5
Number of public wire bits:      51
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 20
$_NOT_                         10
fa1                            10

=== design hierarchy ===

aluuu                             1
adder_10                        1
fa1                          10
ha                          2
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
fa1                          80
ha                          2
ha                           10
orie                            1
sub_10                          1
fa1                          10
ha                          2

Number of wires:               2176
Number of wire bits:           2520
Number of public wires:        1839
Number of public wire bits:    2183
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                910
$_ANDNOT_                      97
$_AND_                        321
$_MUX_                         10
$_NAND_                         3
$_NOR_                          1
$_NOT_                         29
$_ORNOT_                       14
$_OR_                         215
$_XOR_                        220

3.26. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

4. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
cell DFFNEGX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_N_.
cell DFFPOSX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_P_.
cell DFFSR (noninv, pins=5, area=704.00) is a direct match for cell type $_DFFSR_PNN_.
final dff cell mappings:
\DFFNEGX1 _DFF_N_ (.CLK( C), .D( D), .Q( Q));
\DFFPOSX1 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
unmapped dff cell: $_DFF_NN0_
unmapped dff cell: $_DFF_NN1_
unmapped dff cell: $_DFF_NP0_
unmapped dff cell: $_DFF_NP1_
unmapped dff cell: $_DFF_PN0_
unmapped dff cell: $_DFF_PN1_
unmapped dff cell: $_DFF_PP0_
unmapped dff cell: $_DFF_PP1_
unmapped dff cell: $_DFFSR_NNN_
unmapped dff cell: $_DFFSR_NNP_
unmapped dff cell: $_DFFSR_NPN_
unmapped dff cell: $_DFFSR_NPP_
\DFFSR _DFFSR_PNN_ (.CLK( C), .D( D), .Q( Q), .R( R), .S( S));
unmapped dff cell: $_DFFSR_PNP_
unmapped dff cell: $_DFFSR_PPN_
unmapped dff cell: $_DFFSR_PPP_

4.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).
Mapping DFF cells in module `\adder_10':
Mapping DFF cells in module `\adie':
Mapping DFF cells in module `\aluuu':
Mapping DFF cells in module `\arilef':
Mapping DFF cells in module `\aririi':
Mapping DFF cells in module `\comp_10':
Mapping DFF cells in module `\fa1':
Mapping DFF cells in module `\ha':
Mapping DFF cells in module `\multi_10':
Mapping DFF cells in module `\orie':
Mapping DFF cells in module `\sub_10':

5. Executing OPT pass (performing simple optimizations).

5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.

5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.6. Executing OPT_DFF pass (perform DFF optimizations).

5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.9. Finished OPT passes. (There is nothing left to do.)

6. Executing ABC pass (technology mapping using ABC).

6.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

6.2.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.2.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

6.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 167 gates and 254 wires to a netlist network with 87 inputs and 20 outputs.

6.3.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.3.2. Re-integrating ABC results.
ABC RESULTS:            NOR2X1 cells:        7
ABC RESULTS:            NOR3X1 cells:        1
ABC RESULTS:           OAI22X1 cells:       16
ABC RESULTS:           AOI21X1 cells:        7
ABC RESULTS:           AOI22X1 cells:       14
ABC RESULTS:           NAND3X1 cells:       17
ABC RESULTS:             INVX1 cells:       42
ABC RESULTS:           NAND2X1 cells:        4
ABC RESULTS:           OAI21X1 cells:        4
ABC RESULTS:            AND2X2 cells:       10
ABC RESULTS:        internal signals:      147
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

6.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 93 gates and 113 wires to a netlist network with 20 inputs and 3 outputs.

6.6.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.6.2. Re-integrating ABC results.
ABC RESULTS:           XNOR2X1 cells:        7
ABC RESULTS:             INVX1 cells:       22
ABC RESULTS:           NAND2X1 cells:       12
ABC RESULTS:            NOR2X1 cells:       12
ABC RESULTS:             OR2X2 cells:        2
ABC RESULTS:           AOI21X1 cells:        8
ABC RESULTS:           NAND3X1 cells:        5
ABC RESULTS:            AND2X2 cells:        5
ABC RESULTS:           OAI21X1 cells:        8
ABC RESULTS:        internal signals:       90
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

6.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

6.7.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.7.2. Re-integrating ABC results.
ABC RESULTS:             OR2X2 cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

6.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

6.8.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.8.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:        1
ABC RESULTS:            NOR2X1 cells:        2
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

6.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

6.9.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.9.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

6.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

6.10.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.10.2. Re-integrating ABC results.
/usr/local/share/qflow/scripts/spi2xspice.py:32: SyntaxWarning: invalid escape sequence '\*'
ABC RESULTS:             OR2X2 cells:       10
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
ABC RESULTS:        internal signals:        0
/usr/local/share/qflow/scripts/spi2xspice.py:33: SyntaxWarning: invalid escape sequence '\*'
ABC RESULTS:           input signals:       20
subrex  = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
ABC RESULTS:          output signals:       10
/usr/local/share/qflow/scripts/spi2xspice.py:34: SyntaxWarning: invalid escape sequence '\*'
Removing temp directory.
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)

/usr/local/share/qflow/scripts/spi2xspice.py:35: SyntaxWarning: invalid escape sequence '\*'
6.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
comrex  = re.compile('^[\*]+.*$', re.IGNORECASE)
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.
/usr/local/share/qflow/scripts/spi2xspice.py:96: SyntaxWarning: invalid escape sequence '\)'

imprex = re.compile('([10\)])[ \t]+([10\(])')
6.11.1. Executing ABC.
/usr/local/share/qflow/scripts/spi2xspice.py:97: SyntaxWarning: invalid escape sequence '\)'
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
primerex = re.compile('([10\)])[ \t]*\'')
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
/usr/local/share/qflow/scripts/spi2xspice.py:143: SyntaxWarning: invalid escape sequence '\g'
ABC:
psubs = imprex.sub('\g<1>&\g<2>', psubs)
ABC: + read_blif <abc-temp-dir>/input.blif
/usr/local/share/qflow/scripts/spi2xspice.py:208: SyntaxWarning: invalid escape sequence '\*'
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
/usr/local/share/qflow/scripts/spi2xspice.py:209: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
subrex = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
/usr/local/share/qflow/scripts/spi2xspice.py:211: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
comrex = re.compile('^[\*]+.*$', re.IGNORECASE)
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
/usr/local/share/qflow/scripts/spi2xspice.py:212: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
specrex = re.compile('^[\*]+This file may contain array delimiters', re.IGNORECASE)
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
/usr/local/share/qflow/scripts/spi2xspice.py:213: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
/usr/local/share/qflow/scripts/spi2xspice.py:214: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
endrex = re.compile('^[^\*]*[ \t]*.end.*$', re.IGNORECASE)
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
/usr/local/share/qflow/scripts/spi2xspice.py:664: SyntaxWarning: invalid escape sequence '\('
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
outparenrex = re.compile('^[ \t]*\([ \t]*(.+)[ \t]*\)[ \t]*$')
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
/usr/local/share/qflow/scripts/spi2xspice.py:665: SyntaxWarning: invalid escape sequence '\('
ABC: Memory =    0.51 MB. Time =     0.00 sec
parenrex = re.compile('\([ \t]*([^ \t\)|&~^]+)[ \t]*\)')
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
/usr/local/share/qflow/scripts/spi2xspice.py:668: SyntaxWarning: invalid escape sequence '\g'
ABC: + strash
pstring = outparenrex.sub('\g<1>', pstring)
ABC: + scorr
/usr/local/share/qflow/scripts/spi2xspice.py:669: SyntaxWarning: invalid escape sequence '\g'
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
pstring = parenrex.sub('\g<1>', pstring)
ABC: + ifraig
/usr/local/share/qflow/scripts/spi2xspice.py:670: SyntaxWarning: invalid escape sequence '\g'
ABC: + retime
pstring = primerex.sub('~\g<1>', pstring)
ABC: + strash
/usr/local/share/qflow/scripts/spi2xspice.py:678: SyntaxWarning: invalid escape sequence '\('
ABC: + dch -f
cellrex  = re.compile('[ \t]*cell[ \t]*\(([^)]+)\)')

LEF Read, Line 135: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 136: NOTE:  Old format VIARULE ignored.
Qflow project setup
LEF Read, Line 140: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 141: NOTE:  Old format VIARULE ignored.

LEF Read, Line 151: NOTE:  Old format VIARULE ignored.
Technology set to osu035 from existing qflow_vars.sh file
LEF Read, Line 152: NOTE:  Old format VIARULE ignored.
Regenerating files for existing project aluuu
LEF Read, Line 156: NOTE:  Old format VIARULE ignored.
Qrouter detail maze router version 1.4.71.T
LEF Read, Line 157: NOTE:  Old format VIARULE ignored.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
LEF Read, Line 167: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site corner (ignored)
LEF Read, Line 168: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site IO (ignored)
LEF Read, Line 172: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site core (ignored)
LEF Read, Line 173: NOTE:  Old format VIARULE ignored.
LEF read: Processed 3179 lines.
LEF Read: encountered 0 errors and 12 warnings total.
Vertical route layer at non-minimum pitch 3.2.  Using smaller pitch 1.6, will route on 1-of-2 tracks for layer metal4.
Running blif2cel to generate input files for graywolf
blif2cel.tcl --blif /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif  --lef  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef --cel /home/kor-tac/Desktop/physical/alu/layout/aluuu.cel
No aluuu.cel1 file found for project. . . no partial blockages to apply to layout.
No aluuu.cel2 file found for project. . . continuing without pin placement hints
Running GrayWolf placement
graywolf  aluuu
Running getfillcell to determine cell to use for fill.
getfillcell.tcl aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Using cell FILL for fill
Running place2def to translate graywolf output to DEF format.
place2def.tcl aluuu FILL
Running addspacers to generate power stripes and align cell right edge
addspacers.tcl  -stripe 5.0 150.0 PG aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Running arrangepins to adjust pin positions for optimal routing.
arrangepins.tcl  aluuu

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running qrouter 1.4.71.T
qrouter -noc  -s aluuu.cfg

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  migrate_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "migrate_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
Reading DEF data from file aluuu.def.
This action cannot be undone.
LEF read, Line 20 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 20 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 21 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 21 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 22 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 22 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 26 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 26 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 27 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 27 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 28 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 28 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 32 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 32 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 33 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 33 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 34 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 34 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
Processed 3 vias total.
Processed 1231 subcell instances total.
Processed 45 pins total.
Processed 1125 nets total.
Processed 62 special nets total.
DEF read: Processed 13209 lines.
DEF Read: encountered 18 warnings total.
Generating LEF output aluuu.lef for cell aluuu:
Diagnostic:  Write LEF header for cell aluuu
Diagnostic:  Writing LEF output for cell aluuu
Diagnostic:  Scale value is 0.100000
Extracting NOR3X1 into NOR3X1.ext:
Extracting OAI22X1 into OAI22X1.ext:
Extracting AOI22X1 into AOI22X1.ext:
Extracting XNOR2X1 into XNOR2X1.ext:
Extracting NAND3X1 into NAND3X1.ext:
Extracting OAI21X1 into OAI21X1.ext:
Extracting AOI21X1 into AOI21X1.ext:
Extracting NAND2X1 into NAND2X1.ext:
Extracting INVX1 into INVX1.ext:
Extracting BUFX2 into BUFX2.ext:
Extracting FILL into FILL.ext:
Extracting OR2X2 into OR2X2.ext:
Extracting NOR2X1 into NOR2X1.ext:
Extracting AND2X2 into AND2X2.ext:
Extracting aluuu into aluuu.ext:

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl" from command line.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
aluuu: 10000 rects
aluuu: 20000 rects
aluuu: 30000 rects
aluuu: 40000 rects
aluuu: 50000 rects
Processing timestamp mismatches: FILL, NOR2X1, NOR3X1, NAND3X1, OAI21X1, INVX1, NAND2X1, BUFX2, OAI22X1, OR2X2, AND2X2, AOI21X1, AOI22X1, XNOR2X1.

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/generate_gds_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/generate_gds_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Warning: Calma reading is not undoable!  I hope that's OK.
Library written using GDS-II Release 3.0
Library name: iit_stdcells
Reading "FILL".
Moving label "vdd" from space to metal1 in cell FILL.
Moving label "gnd" from space to metal1 in cell FILL.
Reading "AND2X1".
Moving label "Y" from space to metal1 in cell AND2X1.
Moving label "B" from space to metal1 in cell AND2X1.
Moving label "vdd" from space to metal1 in cell AND2X1.
Moving label "gnd" from space to metal1 in cell AND2X1.
Moving label "A" from space to metal1 in cell AND2X1.
Reading "AND2X2".
Moving label "vdd" from space to metal1 in cell AND2X2.
Moving label "gnd" from space to metal1 in cell AND2X2.
Moving label "A" from space to metal1 in cell AND2X2.
Moving label "B" from space to metal1 in cell AND2X2.
Moving label "Y" from space to metal1 in cell AND2X2.
Reading "AOI21X1".
Moving label "gnd" from space to metal1 in cell AOI21X1.
Moving label "vdd" from space to metal1 in cell AOI21X1.
Moving label "A" from space to metal1 in cell AOI21X1.
Moving label "B" from space to metal1 in cell AOI21X1.
Moving label "Y" from space to metal1 in cell AOI21X1.
Moving label "C" from space to metal1 in cell AOI21X1.
Reading "AOI22X1".
Moving label "gnd" from space to metal1 in cell AOI22X1.
Moving label "vdd" from space to metal1 in cell AOI22X1.
Moving label "C" from space to metal1 in cell AOI22X1.
Moving label "D" from space to metal1 in cell AOI22X1.
Moving label "Y" from space to metal1 in cell AOI22X1.
Moving label "A" from space to metal1 in cell AOI22X1.
Moving label "B" from space to metal1 in cell AOI22X1.
Reading "BUFX2".
Moving label "vdd" from space to metal1 in cell BUFX2.
Moving label "gnd" from space to metal1 in cell BUFX2.
Moving label "A" from space to metal1 in cell BUFX2.
Moving label "Y" from space to metal1 in cell BUFX2.
Reading "BUFX4".
Moving label "vdd" from space to metal1 in cell BUFX4.
Moving label "gnd" from space to metal1 in cell BUFX4.
Moving label "A" from space to metal1 in cell BUFX4.
Moving label "Y" from space to metal1 in cell BUFX4.
Reading "DFFNEGX1".
Moving label "CLK" from space to metal1 in cell DFFNEGX1.
Moving label "vdd" from space to metal1 in cell DFFNEGX1.
Moving label "D" from space to metal1 in cell DFFNEGX1.
Moving label "gnd" from space to metal1 in cell DFFNEGX1.
Moving label "Q" from space to metal1 in cell DFFNEGX1.
Reading "NOR3X1".
Moving label "vdd" from space to metal1 in cell NOR3X1.
Moving label "gnd" from space to metal1 in cell NOR3X1.
Moving label "B" from space to metal1 in cell NOR3X1.
Moving label "C" from space to metal1 in cell NOR3X1.
Moving label "A" from space to metal1 in cell NOR3X1.
Moving label "Y" from space to metal1 in cell NOR3X1.
Reading "DFFPOSX1".
Moving label "vdd" from space to metal1 in cell DFFPOSX1.
Moving label "D" from space to metal1 in cell DFFPOSX1.
Moving label "gnd" from space to metal1 in cell DFFPOSX1.
Moving label "Q" from space to metal1 in cell DFFPOSX1.
Moving label "CLK" from space to metal1 in cell DFFPOSX1.
Reading "FAX1".
Moving label "gnd" from space to metal1 in cell FAX1.
Moving label "vdd" from space to metal1 in cell FAX1.
Moving label "A" from space to metal1 in cell FAX1.
Moving label "B" from space to metal1 in cell FAX1.
Moving label "C" from space to metal1 in cell FAX1.
Moving label "YC" from space to metal1 in cell FAX1.
Moving label "YS" from space to metal1 in cell FAX1.
Reading "HAX1".
Moving label "vdd" from space to metal1 in cell HAX1.
Moving label "gnd" from space to metal1 in cell HAX1.
Moving label "YC" from space to metal1 in cell HAX1.
Moving label "A" from space to metal1 in cell HAX1.
Moving label "B" from space to metal1 in cell HAX1.
Moving label "YS" from space to metal1 in cell HAX1.
Reading "INVX1".
Moving label "A" from space to metal1 in cell INVX1.
Moving label "Y" from space to metal1 in cell INVX1.
Moving label "vdd" from space to metal1 in cell INVX1.
Moving label "gnd" from space to metal1 in cell INVX1.
Reading "INVX2".
Moving label "vdd" from space to metal1 in cell INVX2.
Moving label "gnd" from space to metal1 in cell INVX2.
Moving label "Y" from space to metal1 in cell INVX2.
Moving label "A" from space to metal1 in cell INVX2.
Reading "INVX4".
Moving label "vdd" from space to metal1 in cell INVX4.
Moving label "gnd" from space to metal1 in cell INVX4.
Moving label "Y" from space to metal1 in cell INVX4.
Moving label "A" from space to metal1 in cell INVX4.
Reading "INVX8".
Moving label "vdd" from space to metal1 in cell INVX8.
Moving label "gnd" from space to metal1 in cell INVX8.
Moving label "A" from space to metal1 in cell INVX8.
Moving label "Y" from space to metal1 in cell INVX8.
Reading "NAND2X1".
Moving label "vdd" from space to metal1 in cell NAND2X1.
Moving label "Y" from space to metal1 in cell NAND2X1.
Moving label "gnd" from space to metal1 in cell NAND2X1.
Moving label "A" from space to metal1 in cell NAND2X1.
Moving label "B" from space to metal1 in cell NAND2X1.
Reading "NAND3X1".
Moving label "B" from space to metal1 in cell NAND3X1.
Moving label "vdd" from space to metal1 in cell NAND3X1.
Moving label "gnd" from space to metal1 in cell NAND3X1.
Moving label "A" from space to metal1 in cell NAND3X1.
Moving label "C" from space to metal1 in cell NAND3X1.
Moving label "Y" from space to metal1 in cell NAND3X1.
Reading "NOR2X1".
Moving label "vdd" from space to metal1 in cell NOR2X1.
Moving label "B" from space to metal1 in cell NOR2X1.
Moving label "gnd" from space to metal1 in cell NOR2X1.
Moving label "Y" from space to metal1 in cell NOR2X1.
Moving label "A" from space to metal1 in cell NOR2X1.
Reading "OAI21X1".
Moving label "gnd" from space to metal1 in cell OAI21X1.
Moving label "vdd" from space to metal1 in cell OAI21X1.
Moving label "A" from space to metal1 in cell OAI21X1.
Moving label "B" from space to metal1 in cell OAI21X1.
Moving label "Y" from space to metal1 in cell OAI21X1.
Moving label "C" from space to metal1 in cell OAI21X1.
Reading "OAI22X1".
Moving label "gnd" from space to metal1 in cell OAI22X1.
Moving label "vdd" from space to metal1 in cell OAI22X1.
Moving label "D" from space to metal1 in cell OAI22X1.
Moving label "C" from space to metal1 in cell OAI22X1.
Moving label "A" from space to metal1 in cell OAI22X1.
Moving label "B" from space to metal1 in cell OAI22X1.
Moving label "Y" from space to metal1 in cell OAI22X1.
Reading "OR2X1".
Moving label "Y" from space to metal1 in cell OR2X1.
Moving label "B" from space to metal1 in cell OR2X1.
Moving label "vdd" from space to metal1 in cell OR2X1.
Moving label "gnd" from space to metal1 in cell OR2X1.
Moving label "A" from space to metal1 in cell OR2X1.
Reading "OR2X2".
Moving label "Y" from space to metal1 in cell OR2X2.
Moving label "B" from space to metal1 in cell OR2X2.
Moving label "vdd" from space to metal1 in cell OR2X2.
Moving label "gnd" from space to metal1 in cell OR2X2.
Moving label "A" from space to metal1 in cell OR2X2.
Reading "TBUFX1".
Moving label "vdd" from space to metal1 in cell TBUFX1.
Moving label "gnd" from space to metal1 in cell TBUFX1.
Moving label "EN" from space to metal1 in cell TBUFX1.
Moving label "A" from space to metal1 in cell TBUFX1.
Moving label "Y" from space to metal1 in cell TBUFX1.
Reading "TBUFX2".
Moving label "vdd" from space to metal1 in cell TBUFX2.
Moving label "gnd" from space to metal1 in cell TBUFX2.
Moving label "A" from space to metal1 in cell TBUFX2.
Moving label "EN" from space to metal1 in cell TBUFX2.
Moving label "Y" from space to metal1 in cell TBUFX2.
Reading "XOR2X1".
Moving label "Y" from space to metal1 in cell XOR2X1.
Moving label "vdd" from space to metal1 in cell XOR2X1.
Moving label "B" from space to metal1 in cell XOR2X1.
Moving label "A" from space to metal1 in cell XOR2X1.
Moving label "gnd" from space to metal1 in cell XOR2X1.
Reading "MUX2X1".
Moving label "S" from space to metal1 in cell MUX2X1.
Moving label "vdd" from space to metal1 in cell MUX2X1.
Moving label "gnd" from space to metal1 in cell MUX2X1.
Moving label "Y" from space to metal1 in cell MUX2X1.
Moving label "A" from space to metal1 in cell MUX2X1.
Moving label "B" from space to metal1 in cell MUX2X1.
Reading "XNOR2X1".
Moving label "A" from space to metal1 in cell XNOR2X1.
Moving label "B" from space to metal1 in cell XNOR2X1.
Moving label "gnd" from space to metal1 in cell XNOR2X1.
Moving label "vdd" from space to metal1 in cell XNOR2X1.
Moving label "Y" from space to metal1 in cell XNOR2X1.
Reading "LATCH".
Moving label "D" from space to metal1 in cell LATCH.
Moving label "Q" from space to metal1 in cell LATCH.
Moving label "gnd" from space to metal1 in cell LATCH.
Moving label "vdd" from space to metal1 in cell LATCH.
Moving label "CLK" from space to metal1 in cell LATCH.
Reading "DFFSR".
Moving label "gnd" from space to metal1 in cell DFFSR.
Moving label "vdd" from space to metal1 in cell DFFSR.
Moving label "D" from space to metal1 in cell DFFSR.
Moving label "S" from space to metal1 in cell DFFSR.
Moving label "R" from space to metal1 in cell DFFSR.
Moving label "Q" from space to metal1 in cell DFFSR.
Moving label "CLK" from space to metal1 in cell DFFSR.
Reading "CLKBUF1".
Moving label "A" from space to metal1 in cell CLKBUF1.
Moving label "vdd" from space to metal1 in cell CLKBUF1.
Moving label "gnd" from space to metal1 in cell CLKBUF1.
Moving label "Y" from space to metal1 in cell CLKBUF1.
Reading "CLKBUF2".
Moving label "vdd" from space to metal1 in cell CLKBUF2.
Moving label "gnd" from space to metal1 in cell CLKBUF2.
Moving label "A" from space to metal1 in cell CLKBUF2.
Moving label "Y" from space to metal1 in cell CLKBUF2.
Reading "CLKBUF3".
Moving label "gnd" from space to metal1 in cell CLKBUF3.
Moving label "vdd" from space to metal1 in cell CLKBUF3.
Moving label "A" from space to metal1 in cell CLKBUF3.
Moving label "Y" from space to metal1 in cell CLKBUF3.
Reading "iit_stdcells".
aluuu: 10000 rects
aluuu: 20000 rects
aluuu: 30000 rects
aluuu: 40000 rects
aluuu: 50000 rects
Processing timestamp mismatches: FILL, NOR2X1, NOR3X1, NAND3X1, OAI21X1, INVX1, NAND2X1, BUFX2, OAI22X1, OR2X2, AND2X2, AOI21X1, AOI22X1, XNOR2X1.
Writing cell aluuu
Writing cell NOR2X1
Writing cell AND2X2
Writing cell OR2X2
Writing cell FILL
Writing cell BUFX2
Writing cell INVX1
Writing cell NAND2X1
Writing cell OAI21X1
Writing cell AOI21X1
Writing cell NAND3X1
Writing cell XNOR2X1
Writing cell AOI22X1
Writing cell OAI22X1
Writing cell NOR3X1

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running yosys for verilog parsing and synthesis
yosys  -s aluuu.ys

/----------------------------------------------------------------------------\
|                                                                            |
|  yosys -- Yosys Open SYnthesis Suite                                       |
|                                                                            |
|  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
|                                                                            |
|  Permission to use, copy, modify, and/or distribute this software for any  |
|  purpose with or without fee is hereby granted, provided that the above    |
|  copyright notice and this permission notice appear in all copies.         |
|                                                                            |
|  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
|  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
|  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
|  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
|  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
|  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
|  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
|                                                                            |
\----------------------------------------------------------------------------/

Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `aluuu.ys' --

1. Executing Liberty frontend: /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
Imported 39 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/kor-tac/Desktop/physical/alu/source/aluuu.v
Parsing Verilog input from `/home/kor-tac/Desktop/physical/alu/source/aluuu.v' to AST representation.
Generating RTLIL representation for module `\ha'.
Generating RTLIL representation for module `\fa1'.
Generating RTLIL representation for module `\multi_10'.
/home/kor-tac/Desktop/physical/alu/source/aluuu.v:41: Warning: Identifier `\p' is implicitly declared.
Generating RTLIL representation for module `\adder_10'.
Generating RTLIL representation for module `\sub_10'.
Generating RTLIL representation for module `\comp_10'.
Generating RTLIL representation for module `\adie'.
Generating RTLIL representation for module `\orie'.
Generating RTLIL representation for module `\arilef'.
Generating RTLIL representation for module `\aririi'.
Generating RTLIL representation for module `\aluuu'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10

3.1.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10
Removed 0 unused modules.
Mapping positional arguments of cell aluuu.aR1 (aririi).
Mapping positional arguments of cell aluuu.aL1 (arilef).
Mapping positional arguments of cell aluuu.on (orie).
Mapping positional arguments of cell aluuu.an (adie).
Mapping positional arguments of cell aluuu.c1 (comp_10).
Mapping positional arguments of cell aluuu.ss1 (sub_10).
Mapping positional arguments of cell aluuu.a1 (adder_10).
Mapping positional arguments of cell aluuu.m1 (multi_10).
Mapping positional arguments of cell sub_10.f9 (fa1).
Mapping positional arguments of cell sub_10.f8 (fa1).
Mapping positional arguments of cell sub_10.f7 (fa1).
Mapping positional arguments of cell sub_10.f6 (fa1).
Mapping positional arguments of cell sub_10.f5 (fa1).
Mapping positional arguments of cell sub_10.f4 (fa1).
Mapping positional arguments of cell sub_10.f3 (fa1).
Mapping positional arguments of cell sub_10.f2 (fa1).
Mapping positional arguments of cell sub_10.f1 (fa1).
Mapping positional arguments of cell sub_10.f0 (fa1).
Mapping positional arguments of cell adder_10.f9 (fa1).
Mapping positional arguments of cell adder_10.f8 (fa1).
Mapping positional arguments of cell adder_10.f7 (fa1).
Mapping positional arguments of cell adder_10.f6 (fa1).
Mapping positional arguments of cell adder_10.f5 (fa1).
Mapping positional arguments of cell adder_10.f4 (fa1).
Mapping positional arguments of cell adder_10.f3 (fa1).
Mapping positional arguments of cell adder_10.f2 (fa1).
Mapping positional arguments of cell adder_10.f1 (fa1).
Mapping positional arguments of cell adder_10.f0 (fa1).
Mapping positional arguments of cell multi_10.h18 (fa1).
Mapping positional arguments of cell multi_10.f74 (fa1).
Mapping positional arguments of cell multi_10.f73 (fa1).
Mapping positional arguments of cell multi_10.f72 (fa1).
Mapping positional arguments of cell multi_10.f71 (fa1).
Mapping positional arguments of cell multi_10.f70 (fa1).
Mapping positional arguments of cell multi_10.f69 (fa1).
Mapping positional arguments of cell multi_10.f68 (fa1).
Mapping positional arguments of cell multi_10.f67 (fa1).
Mapping positional arguments of cell multi_10.h17 (ha).
Mapping positional arguments of cell multi_10.h16 (fa1).
Mapping positional arguments of cell multi_10.f66 (fa1).
Mapping positional arguments of cell multi_10.f65 (fa1).
Mapping positional arguments of cell multi_10.f64 (fa1).
Mapping positional arguments of cell multi_10.f63 (fa1).
Mapping positional arguments of cell multi_10.f62 (fa1).
Mapping positional arguments of cell multi_10.f61 (fa1).
Mapping positional arguments of cell multi_10.f60 (fa1).
Mapping positional arguments of cell multi_10.f59 (fa1).
Mapping positional arguments of cell multi_10.h15 (ha).
Mapping positional arguments of cell multi_10.h14 (fa1).
Mapping positional arguments of cell multi_10.f58 (fa1).
Mapping positional arguments of cell multi_10.f57 (fa1).
Mapping positional arguments of cell multi_10.f56 (fa1).
Mapping positional arguments of cell multi_10.f53 (fa1).
Mapping positional arguments of cell multi_10.f52 (fa1).
Mapping positional arguments of cell multi_10.f51 (fa1).
Mapping positional arguments of cell multi_10.f50 (fa1).
Mapping positional arguments of cell multi_10.f49 (fa1).
Mapping positional arguments of cell multi_10.h13 (ha).
Mapping positional arguments of cell multi_10.h12 (fa1).
Mapping positional arguments of cell multi_10.f48 (fa1).
Mapping positional arguments of cell multi_10.f47 (fa1).
Mapping positional arguments of cell multi_10.f46 (fa1).
Mapping positional arguments of cell multi_10.f45 (fa1).
Mapping positional arguments of cell multi_10.f44 (fa1).
Mapping positional arguments of cell multi_10.f43 (fa1).
Mapping positional arguments of cell multi_10.f42 (fa1).
Mapping positional arguments of cell multi_10.f41 (fa1).
Mapping positional arguments of cell multi_10.h11 (ha).
Mapping positional arguments of cell multi_10.h10 (fa1).
Mapping positional arguments of cell multi_10.f40 (fa1).
Mapping positional arguments of cell multi_10.f39 (fa1).
Mapping positional arguments of cell multi_10.f38 (fa1).
Mapping positional arguments of cell multi_10.f37 (fa1).
Mapping positional arguments of cell multi_10.f36 (fa1).
Mapping positional arguments of cell multi_10.f35 (fa1).
Mapping positional arguments of cell multi_10.f34 (fa1).
Mapping positional arguments of cell multi_10.f33 (fa1).
Mapping positional arguments of cell multi_10.h9 (ha).
Mapping positional arguments of cell multi_10.h8 (fa1).
Mapping positional arguments of cell multi_10.f32 (fa1).
Mapping positional arguments of cell multi_10.f31 (fa1).
Mapping positional arguments of cell multi_10.f30 (fa1).
Mapping positional arguments of cell multi_10.f29 (fa1).
Mapping positional arguments of cell multi_10.f28 (fa1).
Mapping positional arguments of cell multi_10.f27 (fa1).
Mapping positional arguments of cell multi_10.f26 (fa1).
Mapping positional arguments of cell multi_10.f25 (fa1).
Mapping positional arguments of cell multi_10.h7 (ha).
Mapping positional arguments of cell multi_10.h6 (fa1).
Mapping positional arguments of cell multi_10.f24 (fa1).
Mapping positional arguments of cell multi_10.f23 (fa1).
Mapping positional arguments of cell multi_10.f22 (fa1).
Mapping positional arguments of cell multi_10.f21 (fa1).
Mapping positional arguments of cell multi_10.f20 (fa1).
Mapping positional arguments of cell multi_10.f19 (fa1).
Mapping positional arguments of cell multi_10.f18 (fa1).
Mapping positional arguments of cell multi_10.f17 (fa1).
Mapping positional arguments of cell multi_10.h5 (ha).
Mapping positional arguments of cell multi_10.h4 (fa1).
Mapping positional arguments of cell multi_10.f16 (fa1).
Mapping positional arguments of cell multi_10.f15 (fa1).
Mapping positional arguments of cell multi_10.f14 (fa1).
Mapping positional arguments of cell multi_10.f13 (fa1).
Mapping positional arguments of cell multi_10.f12 (fa1).
Mapping positional arguments of cell multi_10.f11 (fa1).
Mapping positional arguments of cell multi_10.f10 (fa1).
Mapping positional arguments of cell multi_10.f9 (fa1).
Mapping positional arguments of cell multi_10.h3 (ha).
Mapping positional arguments of cell multi_10.h2 (ha).
Mapping positional arguments of cell multi_10.f8 (fa1).
Mapping positional arguments of cell multi_10.f7 (fa1).
Mapping positional arguments of cell multi_10.f6 (fa1).
Mapping positional arguments of cell multi_10.f5 (fa1).
Mapping positional arguments of cell multi_10.f4 (fa1).
Mapping positional arguments of cell multi_10.f3 (fa1).
Mapping positional arguments of cell multi_10.f2 (fa1).
Mapping positional arguments of cell multi_10.f1 (fa1).
Mapping positional arguments of cell multi_10.h1 (ha).
Mapping positional arguments of cell fa1.h2 (ha).
Mapping positional arguments of cell fa1.h1 (ha).
Warning: Resizing cell port aluuu.a1.sum from 10 bits to 11 bits.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed 1 dead cases from process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Marked 1 switch rules as full_case in process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Removed a total of 1 dead cases.

3.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

3.2.4. Executing PROC_INIT pass (extract init attributes).

3.2.5. Executing PROC_ARST pass (detect async resets in processes).

3.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~1 debug messages>

3.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
1/1: $1\y[19:0]

3.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\aluuu.\y' from process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.

3.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Removing empty process `aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Cleaned up 1 empty switch.

3.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module aririi.
<suppressed ~1 debug messages>
Optimizing module arilef.
<suppressed ~1 debug messages>
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
<suppressed ~1 debug messages>
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
Optimizing module aririi.
Optimizing module arilef.
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \sub_10..
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Removed 0 unused cells and 16 unused wires.
<suppressed ~10 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
<suppressed ~486 debug messages>
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 162 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.6. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 162 unused wires.
<suppressed ~1 debug messages>

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.16. Finished OPT passes. (There is nothing left to do.)

3.7. Executing FSM pass (extract and optimize FSM).

3.7.1. Executing FSM_DETECT pass (finding FSMs in design).

3.7.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.7.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.7.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.7.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.7.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.8. Executing OPT pass (performing simple optimizations).

3.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.6. Executing OPT_DFF pass (perform DFF optimizations).

3.8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.9. Finished OPT passes. (There is nothing left to do.)

3.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$373_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$374_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell aluuu.$procmux$375_CMP0 ($eq).

3.10. Executing PEEPOPT pass (run peephole optimizers).

3.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.12. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module adder_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module adie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aluuu:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arilef:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aririi:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module comp_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module fa1:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module ha:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module multi_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module orie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module sub_10:
created 0 $alu and 0 $macc cells.

3.13. Executing SHARE pass (SAT-based resource sharing).

3.14. Executing OPT pass (performing simple optimizations).

3.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.6. Executing OPT_DFF pass (perform DFF optimizations).

3.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.9. Finished OPT passes. (There is nothing left to do.)

3.15. Executing MEMORY pass.

3.15.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.15.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.15.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.15.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.15.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.15.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.15.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.15.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.17. Executing OPT pass (performing simple optimizations).

3.17.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.17.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.17.3. Executing OPT_DFF pass (perform DFF optimizations).

3.17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

3.17.5. Finished fast OPT passes.

3.18. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

3.19. Executing OPT pass (performing simple optimizations).

3.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.6. Executing OPT_SHARE pass.

3.19.7. Executing OPT_DFF pass (perform DFF optimizations).

3.19.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.19.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.10. Finished OPT passes. (There is nothing left to do.)

3.20. Executing TECHMAP pass (map to technology primitives).

3.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.20.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $xnor.
Using extmapper simplemap for cells of type $eq.
Using template $paramod$43fa60c46e83442767389184ae02572e3838275f\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $mux.
No more expansions possible.
<suppressed ~324 debug messages>

3.21. Executing OPT pass (performing simple optimizations).

3.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~153 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
<suppressed ~36 debug messages>
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 12 cells.

3.21.3. Executing OPT_DFF pass (perform DFF optimizations).

3.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 125 unused wires.
<suppressed ~1 debug messages>

3.21.5. Finished fast OPT passes.

3.22. Executing ABC pass (technology mapping using ABC).

3.22.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.2.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 175 gates and 263 wires to a netlist network with 87 inputs and 20 outputs.

3.22.3.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.3.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:              NAND cells:        3
ABC RESULTS:                OR cells:       61
ABC RESULTS:               MUX cells:       10
ABC RESULTS:             ORNOT cells:       14
ABC RESULTS:            ANDNOT cells:       77
ABC RESULTS:        internal signals:      156
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

3.22.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 95 gates and 115 wires to a netlist network with 20 inputs and 3 outputs.

3.22.6.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.6.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       10
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:       18
ABC RESULTS:            ANDNOT cells:       20
ABC RESULTS:                OR cells:       44
ABC RESULTS:        internal signals:       92
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

3.22.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

3.22.7.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.7.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

3.22.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

3.22.8.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.8.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

3.22.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

3.22.9.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

3.22.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.10.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.10.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.

3.22.11.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.11.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:       10
Removing temp directory.

3.23. Executing OPT pass (performing simple optimizations).

3.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.23.3. Executing OPT_DFF pass (perform DFF optimizations).

3.23.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 469 unused wires.
<suppressed ~8 debug messages>

3.23.5. Finished fast OPT passes.

3.24. Executing HIERARCHY pass (managing design hierarchy).

3.24.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10

3.24.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10
Removed 0 unused modules.

3.25. Printing statistics.

=== adder_10 ===

Number of wires:                  4
Number of wire bits:             40
Number of public wires:           4
Number of public wire bits:      40
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
fa1                            10

=== adie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_AND_                         10

=== aluuu ===

Number of wires:                160
Number of wire bits:            275
Number of public wires:          12
Number of public wire bits:     127
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                175
$_ANDNOT_                      77
$_AND_                          1
$_MUX_                         10
$_NAND_                         3
$_NOT_                          1
$_ORNOT_                       14
$_OR_                          61
adder_10                        1
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
orie                            1
sub_10                          1

=== arilef ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== aririi ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== comp_10 ===

Number of wires:                 93
Number of wire bits:            113
Number of public wires:           3
Number of public wire bits:      23
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 93
$_ANDNOT_                      20
$_NOR_                          1
$_NOT_                         18
$_OR_                          44
$_XOR_                         10

=== fa1 ===

Number of wires:                  8
Number of wire bits:              8
Number of public wires:           8
Number of public wire bits:       8
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  3
$_OR_                           1
ha                              2

=== ha ===

Number of wires:                  4
Number of wire bits:              4
Number of public wires:           4
Number of public wire bits:       4
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  2
$_AND_                          1
$_XOR_                          1

=== multi_10 ===

Number of wires:                264
Number of wire bits:            301
Number of public wires:         165
Number of public wire bits:     202
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                190
$_AND_                        100
fa1                            80
ha                             10

=== orie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_OR_                          10

=== sub_10 ===

Number of wires:                  5
Number of wire bits:             51
Number of public wires:           5
Number of public wire bits:      51
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 20
$_NOT_                         10
fa1                            10

=== design hierarchy ===

aluuu                             1
adder_10                        1
fa1                          10
ha                          2
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
fa1                          80
ha                          2
ha                           10
orie                            1
sub_10                          1
fa1                          10
ha                          2

Number of wires:               2176
Number of wire bits:           2520
Number of public wires:        1839
Number of public wire bits:    2183
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                910
$_ANDNOT_                      97
$_AND_                        321
$_MUX_                         10
$_NAND_                         3
$_NOR_                          1
$_NOT_                         29
$_ORNOT_                       14
$_OR_                         215
$_XOR_                        220

3.26. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

4. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
cell DFFNEGX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_N_.
cell DFFPOSX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_P_.
cell DFFSR (noninv, pins=5, area=704.00) is a direct match for cell type $_DFFSR_PNN_.
final dff cell mappings:
\DFFNEGX1 _DFF_N_ (.CLK( C), .D( D), .Q( Q));
\DFFPOSX1 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
unmapped dff cell: $_DFF_NN0_
unmapped dff cell: $_DFF_NN1_
unmapped dff cell: $_DFF_NP0_
unmapped dff cell: $_DFF_NP1_
unmapped dff cell: $_DFF_PN0_
unmapped dff cell: $_DFF_PN1_
unmapped dff cell: $_DFF_PP0_
unmapped dff cell: $_DFF_PP1_
unmapped dff cell: $_DFFSR_NNN_
unmapped dff cell: $_DFFSR_NNP_
unmapped dff cell: $_DFFSR_NPN_
unmapped dff cell: $_DFFSR_NPP_
\DFFSR _DFFSR_PNN_ (.CLK( C), .D( D), .Q( Q), .R( R), .S( S));
unmapped dff cell: $_DFFSR_PNP_
unmapped dff cell: $_DFFSR_PPN_
unmapped dff cell: $_DFFSR_PPP_

4.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).
Mapping DFF cells in module `\adder_10':
Mapping DFF cells in module `\adie':
Mapping DFF cells in module `\aluuu':
Mapping DFF cells in module `\arilef':
Mapping DFF cells in module `\aririi':
Mapping DFF cells in module `\comp_10':
Mapping DFF cells in module `\fa1':
Mapping DFF cells in module `\ha':
Mapping DFF cells in module `\multi_10':
Mapping DFF cells in module `\orie':
Mapping DFF cells in module `\sub_10':

5. Executing OPT pass (performing simple optimizations).

5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.

5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.6. Executing OPT_DFF pass (perform DFF optimizations).

5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.9. Finished OPT passes. (There is nothing left to do.)

6. Executing ABC pass (technology mapping using ABC).

6.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

6.2.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.2.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

6.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 167 gates and 254 wires to a netlist network with 87 inputs and 20 outputs.

6.3.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.3.2. Re-integrating ABC results.
ABC RESULTS:            NOR2X1 cells:        7
ABC RESULTS:            NOR3X1 cells:        1
ABC RESULTS:           OAI22X1 cells:       16
ABC RESULTS:           AOI21X1 cells:        7
ABC RESULTS:           AOI22X1 cells:       14
ABC RESULTS:           NAND3X1 cells:       17
ABC RESULTS:             INVX1 cells:       42
ABC RESULTS:           NAND2X1 cells:        4
ABC RESULTS:           OAI21X1 cells:        4
ABC RESULTS:            AND2X2 cells:       10
ABC RESULTS:        internal signals:      147
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

6.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 93 gates and 113 wires to a netlist network with 20 inputs and 3 outputs.

6.6.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.6.2. Re-integrating ABC results.
ABC RESULTS:           XNOR2X1 cells:        7
ABC RESULTS:             INVX1 cells:       22
ABC RESULTS:           NAND2X1 cells:       12
ABC RESULTS:            NOR2X1 cells:       12
ABC RESULTS:             OR2X2 cells:        2
ABC RESULTS:           AOI21X1 cells:        8
ABC RESULTS:           NAND3X1 cells:        5
ABC RESULTS:            AND2X2 cells:        5
ABC RESULTS:           OAI21X1 cells:        8
ABC RESULTS:        internal signals:       90
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

6.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

6.7.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.7.2. Re-integrating ABC results.
ABC RESULTS:             OR2X2 cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

6.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

6.8.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.8.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:        1
ABC RESULTS:            NOR2X1 cells:        2
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

6.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

6.9.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.9.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

6.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

6.10.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.10.2. Re-integrating ABC results.
ABC RESULTS:             OR2X2 cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

6.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.

6.11.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "PADINOUT".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Scl_LibertyReadGenlib() skipped cell "PADFC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADNC" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADVDD" without logic function.
ABC: Scl_LibertyReadGenlib() skipped cell "PADGND" without logic function.
ABC: Library "osu035_stdcells" from "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" has 28 cells (11 skipped: 4 seq; 3 tri-state; 4 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.51 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.11.2. Re-integrating ABC results.
ABC RESULTS:             INVX1 cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:       10
Removing temp directory.

7. Executing FLATTEN pass (flatten design).
Deleting now unused module adder_10.
Deleting now unused module adie.
Deleting now unused module arilef.
Deleting now unused module aririi.
Deleting now unused module comp_10.
Deleting now unused module fa1.
Deleting now unused module ha.
Deleting now unused module multi_10.
Deleting now unused module orie.
Deleting now unused module sub_10.
<suppressed ~120 debug messages>

8. Executing SETUNDEF pass (replace undef values with defined constants).
Removed 2 unused cells and 3011 unused wires.

9. Executing IOPADMAP pass (mapping inputs/outputs to IO-PAD cells).
Don't map input port aluuu.a: Missing option -inpad.
Don't map input port aluuu.b: Missing option -inpad.
Don't map input port aluuu.sel: Missing option -inpad.
Mapping port aluuu.y using BUFX2.

10. Executing OPT pass (performing simple optimizations).

10.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.

10.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\aluuu'.
Removed a total of 0 cells.

10.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.

10.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \aluuu.
Performed a total of 0 changes.

10.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\aluuu'.
Removed a total of 0 cells.

10.6. Executing OPT_DFF pass (perform DFF optimizations).

/usr/local/share/qflow/scripts/spi2xspice.py:32: SyntaxWarning: invalid escape sequence '\*'
10.7. Executing OPT_CLEAN pass (remove unused cells and wires).
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
Finding unused cells or wires in module \aluuu..
/usr/local/share/qflow/scripts/spi2xspice.py:33: SyntaxWarning: invalid escape sequence '\*'

subrex  = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
10.8. Executing OPT_EXPR pass (perform const folding).
/usr/local/share/qflow/scripts/spi2xspice.py:34: SyntaxWarning: invalid escape sequence '\*'
Optimizing module aluuu.
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)

/usr/local/share/qflow/scripts/spi2xspice.py:35: SyntaxWarning: invalid escape sequence '\*'
10.9. Finished OPT passes. (There is nothing left to do.)
comrex  = re.compile('^[\*]+.*$', re.IGNORECASE)

/usr/local/share/qflow/scripts/spi2xspice.py:96: SyntaxWarning: invalid escape sequence '\)'
11. Executing BLIF backend.
imprex = re.compile('([10\)])[ \t]+([10\(])')

/usr/local/share/qflow/scripts/spi2xspice.py:97: SyntaxWarning: invalid escape sequence '\)'
12. Printing statistics.
primerex = re.compile('([10\)])[ \t]*\'')

/usr/local/share/qflow/scripts/spi2xspice.py:143: SyntaxWarning: invalid escape sequence '\g'
=== aluuu ===
psubs = imprex.sub('\g<1>&\g<2>', psubs)

/usr/local/share/qflow/scripts/spi2xspice.py:208: SyntaxWarning: invalid escape sequence '\*'
Number of wires:               1026
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
Number of wire bits:           1123
/usr/local/share/qflow/scripts/spi2xspice.py:209: SyntaxWarning: invalid escape sequence '\*'
Number of public wires:        1026
subrex = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
Number of public wire bits:    1123
/usr/local/share/qflow/scripts/spi2xspice.py:211: SyntaxWarning: invalid escape sequence '\*'
Number of memories:               0
comrex = re.compile('^[\*]+.*$', re.IGNORECASE)
Number of memory bits:            0
/usr/local/share/qflow/scripts/spi2xspice.py:212: SyntaxWarning: invalid escape sequence '\*'
Number of processes:              0
specrex = re.compile('^[\*]+This file may contain array delimiters', re.IGNORECASE)
Number of cells:               1081
/usr/local/share/qflow/scripts/spi2xspice.py:213: SyntaxWarning: invalid escape sequence '\*'
AND2X2                        335
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
AOI21X1                        15
/usr/local/share/qflow/scripts/spi2xspice.py:214: SyntaxWarning: invalid escape sequence '\*'
AOI22X1                        14
endrex = re.compile('^[^\*]*[ \t]*.end.*$', re.IGNORECASE)
BUFX2                          20
/usr/local/share/qflow/scripts/spi2xspice.py:664: SyntaxWarning: invalid escape sequence '\('
INVX1                          74
outparenrex = re.compile('^[ \t]*\([ \t]*(.+)[ \t]*\)[ \t]*$')
NAND2X1                        16
/usr/local/share/qflow/scripts/spi2xspice.py:665: SyntaxWarning: invalid escape sequence '\('
NAND3X1                        22
parenrex = re.compile('\([ \t]*([^ \t\)|&~^]+)[ \t]*\)')
NOR2X1                        439
/usr/local/share/qflow/scripts/spi2xspice.py:668: SyntaxWarning: invalid escape sequence '\g'
NOR3X1                          1
pstring = outparenrex.sub('\g<1>', pstring)
OAI21X1                        12
/usr/local/share/qflow/scripts/spi2xspice.py:669: SyntaxWarning: invalid escape sequence '\g'
OAI22X1                        16
pstring = parenrex.sub('\g<1>', pstring)
OR2X2                         110
/usr/local/share/qflow/scripts/spi2xspice.py:670: SyntaxWarning: invalid escape sequence '\g'
XNOR2X1                         7
pstring = primerex.sub('~\g<1>', pstring)

/usr/local/share/qflow/scripts/spi2xspice.py:678: SyntaxWarning: invalid escape sequence '\('
Warnings: 2 unique messages, 2 total
cellrex  = re.compile('[ \t]*cell[ \t]*\(([^)]+)\)')
End of script. Logfile hash: 5ba69506a9, CPU: user 0.53s system 0.05s, MEM: 28.18 MB peak
/usr/local/share/qflow/scripts/spi2xspice.py:679: SyntaxWarning: invalid escape sequence '\('
Yosys 0.33 (git sha1 2584903a060)
pinrex   = re.compile('[ \t]*pin[ \t]*\(([^)]+)\)')
Time spent: 56% 2x abc (0 sec), 8% 18x opt_expr (0 sec), ...
/usr/local/share/qflow/scripts/spi2xspice.py:680: SyntaxWarning: invalid escape sequence '\('
Running getpowerground to determine power and ground net names.
busrex   = re.compile('[ \t]*bus[ \t]*\(([^)]+)\)')
getpowerground.tcl  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef
/usr/local/share/qflow/scripts/spi2xspice.py:681: SyntaxWarning: invalid escape sequence '\('
Cleaning up output syntax
lat1rex  = re.compile('[ \t]*latch[ \t]*\(([^)]+)\)')
ypostproc.tcl aluuu_mapped.blif aluuu /usr/local/share/qflow/tech/osu035/osu035.sh vdd gnd
/usr/local/share/qflow/scripts/spi2xspice.py:682: SyntaxWarning: invalid escape sequence '\('
Yosys syntax postprocessing
lat2rex  = re.compile('[ \t]*latch[ \t]*\(([^, \t]+)[ \t]*,[ \t]*([^),]+)\)')
Cleaning up blif file syntax
/usr/local/share/qflow/scripts/spi2xspice.py:683: SyntaxWarning: invalid escape sequence '\('
blifFanout not run:  No cell size optimization.
ff1rex   = re.compile('[ \t]*ff[ \t]*\(([^)]+)\)')
Generating RTL verilog and SPICE netlist file in directory
/usr/local/share/qflow/scripts/spi2xspice.py:684: SyntaxWarning: invalid escape sequence '\('
/home/kor-tac/Desktop/physical/alu/synthesis
ff2rex   = re.compile('[ \t]*ff[ \t]*\(([^, \t]+)[ \t]*,[ \t]*([^),]+)\)')
Files:
Verilog: /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.rtl.v
Verilog: /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.rtlnopwr.v
Verilog: /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.rtlbb.v
Spice:   /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.spc
Running blif2Verilog.
Running blif2BSpice.
Running spi2xspice.py
spi2xspice.py "/usr/local/share/qflow/tech/osu035/osu035_stdcells.lib" aluuu.spc aluuu.xspice
Reading liberty netlist /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
Reading spice netlist aluuu.spc
Writing xspice netlist aluuu.xspice
Writing xspice file
Done.


LEF Read, Line 135: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 136: NOTE:  Old format VIARULE ignored.
Qflow project setup
LEF Read, Line 140: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 141: NOTE:  Old format VIARULE ignored.

LEF Read, Line 151: NOTE:  Old format VIARULE ignored.
Technology set to osu035 from existing qflow_vars.sh file
LEF Read, Line 152: NOTE:  Old format VIARULE ignored.
Regenerating files for existing project aluuu
LEF Read, Line 156: NOTE:  Old format VIARULE ignored.
Qrouter detail maze router version 1.4.71.T
LEF Read, Line 157: NOTE:  Old format VIARULE ignored.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
LEF Read, Line 167: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site corner (ignored)
LEF Read, Line 168: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site IO (ignored)
LEF Read, Line 172: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site core (ignored)
LEF Read, Line 173: NOTE:  Old format VIARULE ignored.
LEF read: Processed 3179 lines.
LEF Read: encountered 0 errors and 12 warnings total.
Vertical route layer at non-minimum pitch 3.2.  Using smaller pitch 1.6, will route on 1-of-2 tracks for layer metal4.
Running blif2cel to generate input files for graywolf
blif2cel.tcl --blif /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif  --lef  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef --cel /home/kor-tac/Desktop/physical/alu/layout/aluuu.cel
No aluuu.cel1 file found for project. . . no partial blockages to apply to layout.
No aluuu.cel2 file found for project. . . continuing without pin placement hints
Running GrayWolf placement
graywolf  aluuu
Running getfillcell to determine cell to use for fill.
getfillcell.tcl aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Using cell FILL for fill
Running place2def to translate graywolf output to DEF format.
place2def.tcl aluuu FILL
Running addspacers to generate power stripes and align cell right edge
addspacers.tcl  -stripe 5.0 150.0 PG aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Running arrangepins to adjust pin positions for optimal routing.
arrangepins.tcl  aluuu
Reading info file aluuu.info. . .
Reading DEF file aluuu.def. . .
Recalculating pin positions
Writing DEF file aluuu_mod.def. . .
Done with arrangepins.tcl
blifanno.tcl /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif aluuu.def /home/kor-tac/Desktop/physical/alu/synthesis/aluuu_anno.blif

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running qrouter 1.4.71.T
qrouter -noc  -s aluuu.cfg

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  migrate_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "migrate_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
Reading DEF data from file aluuu.def.
This action cannot be undone.
LEF read, Line 20 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 20 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 21 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 21 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 22 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 22 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 26 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 26 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 27 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 27 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 28 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 28 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 32 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 32 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 33 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 33 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 34 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 34 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
Processed 3 vias total.
Processed 1231 subcell instances total.
Processed 45 pins total.
Processed 1125 nets total.
Processed 62 special nets total.
DEF read: Processed 13209 lines.
DEF Read: encountered 18 warnings total.
Generating LEF output aluuu.lef for cell aluuu:
Diagnostic:  Write LEF header for cell aluuu
Diagnostic:  Writing LEF output for cell aluuu
Diagnostic:  Scale value is 0.100000
Extracting NOR3X1 into NOR3X1.ext:
Extracting OAI22X1 into OAI22X1.ext:
Extracting AOI22X1 into AOI22X1.ext:
Extracting XNOR2X1 into XNOR2X1.ext:
Extracting NAND3X1 into NAND3X1.ext:
Extracting OAI21X1 into OAI21X1.ext:
Extracting AOI21X1 into AOI21X1.ext:
Extracting NAND2X1 into NAND2X1.ext:
Extracting INVX1 into INVX1.ext:
Extracting BUFX2 into BUFX2.ext:
Extracting FILL into FILL.ext:
Extracting OR2X2 into OR2X2.ext:
Extracting NOR2X1 into NOR2X1.ext:
Extracting AND2X2 into AND2X2.ext:
Extracting aluuu into aluuu.ext:
exttospice finished.

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl" from command line.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
aluuu: 10000 rects
aluuu: 20000 rects

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/generate_gds_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/generate_gds_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Warning: Calma reading is not undoable!  I hope that's OK.
Library written using GDS-II Release 3.0
Library name: iit_stdcells
Reading "FILL".
Moving label "vdd" from space to metal1 in cell FILL.
Moving label "gnd" from space to metal1 in cell FILL.
Reading "AND2X1".
Moving label "Y" from space to metal1 in cell AND2X1.
Moving label "B" from space to metal1 in cell AND2X1.
Moving label "vdd" from space to metal1 in cell AND2X1.
Moving label "gnd" from space to metal1 in cell AND2X1.
Moving label "A" from space to metal1 in cell AND2X1.
Reading "AND2X2".
Moving label "vdd" from space to metal1 in cell AND2X2.
Moving label "gnd" from space to metal1 in cell AND2X2.
Moving label "A" from space to metal1 in cell AND2X2.
Moving label "B" from space to metal1 in cell AND2X2.
Moving label "Y" from space to metal1 in cell AND2X2.
Reading "AOI21X1".
Moving label "gnd" from space to metal1 in cell AOI21X1.
Moving label "vdd" from space to metal1 in cell AOI21X1.
Moving label "A" from space to metal1 in cell AOI21X1.
Moving label "B" from space to metal1 in cell AOI21X1.
Moving label "Y" from space to metal1 in cell AOI21X1.
Moving label "C" from space to metal1 in cell AOI21X1.
Reading "AOI22X1".
Moving label "gnd" from space to metal1 in cell AOI22X1.
Moving label "vdd" from space to metal1 in cell AOI22X1.
Moving label "C" from space to metal1 in cell AOI22X1.
Moving label "D" from space to metal1 in cell AOI22X1.
Moving label "Y" from space to metal1 in cell AOI22X1.
Moving label "A" from space to metal1 in cell AOI22X1.
Moving label "B" from space to metal1 in cell AOI22X1.
Reading "BUFX2".
Moving label "vdd" from space to metal1 in cell BUFX2.
Moving label "gnd" from space to metal1 in cell BUFX2.
Moving label "A" from space to metal1 in cell BUFX2.
Moving label "Y" from space to metal1 in cell BUFX2.
Reading "BUFX4".
Moving label "vdd" from space to metal1 in cell BUFX4.
Moving label "gnd" from space to metal1 in cell BUFX4.
Moving label "A" from space to metal1 in cell BUFX4.
Moving label "Y" from space to metal1 in cell BUFX4.
Reading "DFFNEGX1".
Moving label "CLK" from space to metal1 in cell DFFNEGX1.
Moving label "vdd" from space to metal1 in cell DFFNEGX1.
Moving label "D" from space to metal1 in cell DFFNEGX1.
Moving label "gnd" from space to metal1 in cell DFFNEGX1.
Moving label "Q" from space to metal1 in cell DFFNEGX1.
Reading "NOR3X1".
Moving label "vdd" from space to metal1 in cell NOR3X1.
Moving label "gnd" from space to metal1 in cell NOR3X1.
Moving label "B" from space to metal1 in cell NOR3X1.
Moving label "C" from space to metal1 in cell NOR3X1.
Moving label "A" from space to metal1 in cell NOR3X1.
Moving label "Y" from space to metal1 in cell NOR3X1.
Reading "DFFPOSX1".
Moving label "vdd" from space to metal1 in cell DFFPOSX1.
Moving label "D" from space to metal1 in cell DFFPOSX1.
Moving label "gnd" from space to metal1 in cell DFFPOSX1.
Moving label "Q" from space to metal1 in cell DFFPOSX1.
Moving label "CLK" from space to metal1 in cell DFFPOSX1.
Reading "FAX1".
Moving label "gnd" from space to metal1 in cell FAX1.
Moving label "vdd" from space to metal1 in cell FAX1.
Moving label "A" from space to metal1 in cell FAX1.
Moving label "B" from space to metal1 in cell FAX1.
Moving label "C" from space to metal1 in cell FAX1.
Moving label "YC" from space to metal1 in cell FAX1.
Moving label "YS" from space to metal1 in cell FAX1.
Reading "HAX1".
Moving label "vdd" from space to metal1 in cell HAX1.
Moving label "gnd" from space to metal1 in cell HAX1.
Moving label "YC" from space to metal1 in cell HAX1.
Moving label "A" from space to metal1 in cell HAX1.
Moving label "B" from space to metal1 in cell HAX1.
Moving label "YS" from space to metal1 in cell HAX1.
Reading "INVX1".
Moving label "A" from space to metal1 in cell INVX1.
Moving label "Y" from space to metal1 in cell INVX1.
Moving label "vdd" from space to metal1 in cell INVX1.
Moving label "gnd" from space to metal1 in cell INVX1.
Reading "INVX2".
Moving label "vdd" from space to metal1 in cell INVX2.
Moving label "gnd" from space to metal1 in cell INVX2.
Moving label "Y" from space to metal1 in cell INVX2.
Moving label "A" from space to metal1 in cell INVX2.
Reading "INVX4".
Moving label "vdd" from space to metal1 in cell INVX4.
Moving label "gnd" from space to metal1 in cell INVX4.
Moving label "Y" from space to metal1 in cell INVX4.
Moving label "A" from space to metal1 in cell INVX4.
Reading "INVX8".
Moving label "vdd" from space to metal1 in cell INVX8.
Moving label "gnd" from space to metal1 in cell INVX8.
Moving label "A" from space to metal1 in cell INVX8.
Moving label "Y" from space to metal1 in cell INVX8.
Reading "NAND2X1".
Moving label "vdd" from space to metal1 in cell NAND2X1.
Moving label "Y" from space to metal1 in cell NAND2X1.
Moving label "gnd" from space to metal1 in cell NAND2X1.
Moving label "A" from space to metal1 in cell NAND2X1.
Moving label "B" from space to metal1 in cell NAND2X1.
Reading "NAND3X1".
Moving label "B" from space to metal1 in cell NAND3X1.
Moving label "vdd" from space to metal1 in cell NAND3X1.
Moving label "gnd" from space to metal1 in cell NAND3X1.
Moving label "A" from space to metal1 in cell NAND3X1.
Moving label "C" from space to metal1 in cell NAND3X1.
Moving label "Y" from space to metal1 in cell NAND3X1.
Reading "NOR2X1".
Moving label "vdd" from space to metal1 in cell NOR2X1.
Moving label "B" from space to metal1 in cell NOR2X1.
Moving label "gnd" from space to metal1 in cell NOR2X1.
Moving label "Y" from space to metal1 in cell NOR2X1.
Moving label "A" from space to metal1 in cell NOR2X1.
Reading "OAI21X1".
Moving label "gnd" from space to metal1 in cell OAI21X1.
Moving label "vdd" from space to metal1 in cell OAI21X1.
Moving label "A" from space to metal1 in cell OAI21X1.
Moving label "B" from space to metal1 in cell OAI21X1.
Moving label "Y" from space to metal1 in cell OAI21X1.
Moving label "C" from space to metal1 in cell OAI21X1.
Reading "OAI22X1".
Moving label "gnd" from space to metal1 in cell OAI22X1.
Moving label "vdd" from space to metal1 in cell OAI22X1.
Moving label "D" from space to metal1 in cell OAI22X1.
Moving label "C" from space to metal1 in cell OAI22X1.
Moving label "A" from space to metal1 in cell OAI22X1.
Moving label "B" from space to metal1 in cell OAI22X1.
Moving label "Y" from space to metal1 in cell OAI22X1.
Reading "OR2X1".
Moving label "Y" from space to metal1 in cell OR2X1.
Moving label "B" from space to metal1 in cell OR2X1.
Moving label "vdd" from space to metal1 in cell OR2X1.
Moving label "gnd" from space to metal1 in cell OR2X1.
Moving label "A" from space to metal1 in cell OR2X1.
Reading "OR2X2".
Moving label "Y" from space to metal1 in cell OR2X2.
Moving label "B" from space to metal1 in cell OR2X2.
Moving label "vdd" from space to metal1 in cell OR2X2.
Moving label "gnd" from space to metal1 in cell OR2X2.
Moving label "A" from space to metal1 in cell OR2X2.
Reading "TBUFX1".
Moving label "vdd" from space to metal1 in cell TBUFX1.
Moving label "gnd" from space to metal1 in cell TBUFX1.
Moving label "EN" from space to metal1 in cell TBUFX1.
Moving label "A" from space to metal1 in cell TBUFX1.
Moving label "Y" from space to metal1 in cell TBUFX1.
Reading "TBUFX2".
Moving label "vdd" from space to metal1 in cell TBUFX2.
Moving label "gnd" from space to metal1 in cell TBUFX2.
Moving label "A" from space to metal1 in cell TBUFX2.
Moving label "EN" from space to metal1 in cell TBUFX2.
Moving label "Y" from space to metal1 in cell TBUFX2.
Reading "XOR2X1".
Moving label "Y" from space to metal1 in cell XOR2X1.
Moving label "vdd" from space to metal1 in cell XOR2X1.
Moving label "B" from space to metal1 in cell XOR2X1.
Moving label "A" from space to metal1 in cell XOR2X1.
Moving label "gnd" from space to metal1 in cell XOR2X1.
Reading "MUX2X1".
Moving label "S" from space to metal1 in cell MUX2X1.
Moving label "vdd" from space to metal1 in cell MUX2X1.
Moving label "gnd" from space to metal1 in cell MUX2X1.
Moving label "Y" from space to metal1 in cell MUX2X1.
Moving label "A" from space to metal1 in cell MUX2X1.
Moving label "B" from space to metal1 in cell MUX2X1.
Reading "XNOR2X1".
Moving label "A" from space to metal1 in cell XNOR2X1.
Moving label "B" from space to metal1 in cell XNOR2X1.
Moving label "gnd" from space to metal1 in cell XNOR2X1.
Moving label "vdd" from space to metal1 in cell XNOR2X1.
Moving label "Y" from space to metal1 in cell XNOR2X1.
Reading "LATCH".
Moving label "D" from space to metal1 in cell LATCH.
Moving label "Q" from space to metal1 in cell LATCH.
Moving label "gnd" from space to metal1 in cell LATCH.
Moving label "vdd" from space to metal1 in cell LATCH.
Moving label "CLK" from space to metal1 in cell LATCH.
Reading "DFFSR".
Moving label "gnd" from space to metal1 in cell DFFSR.
Moving label "vdd" from space to metal1 in cell DFFSR.
Moving label "D" from space to metal1 in cell DFFSR.
Moving label "S" from space to metal1 in cell DFFSR.
Moving label "R" from space to metal1 in cell DFFSR.
Moving label "Q" from space to metal1 in cell DFFSR.
Moving label "CLK" from space to metal1 in cell DFFSR.
Reading "CLKBUF1".
Moving label "A" from space to metal1 in cell CLKBUF1.
Moving label "vdd" from space to metal1 in cell CLKBUF1.
Moving label "gnd" from space to metal1 in cell CLKBUF1.
Moving label "Y" from space to metal1 in cell CLKBUF1.
Reading "CLKBUF2".
Moving label "vdd" from space to metal1 in cell CLKBUF2.
Moving label "gnd" from space to metal1 in cell CLKBUF2.
Moving label "A" from space to metal1 in cell CLKBUF2.
Moving label "Y" from space to metal1 in cell CLKBUF2.
Reading "CLKBUF3".
Moving label "gnd" from space to metal1 in cell CLKBUF3.
Moving label "vdd" from space to metal1 in cell CLKBUF3.
Moving label "A" from space to metal1 in cell CLKBUF3.
Moving label "Y" from space to metal1 in cell CLKBUF3.
Reading "iit_stdcells".
aluuu: 10000 rects
aluuu: 20000 rects
aluuu: 30000 rects
aluuu: 40000 rects
aluuu: 50000 rects
Processing timestamp mismatches: FILL, NOR2X1, NOR3X1, NAND3X1, OAI21X1, INVX1, NAND2X1, BUFX2, OAI22X1, OR2X2, AND2X2, AOI21X1, AOI22X1, XNOR2X1.
Writing cell aluuu
Writing cell NOR2X1
Writing cell AND2X2
Writing cell OR2X2
Writing cell FILL
Writing cell BUFX2
Writing cell INVX1
Writing cell NAND2X1
Writing cell OAI21X1
Writing cell AOI21X1
Writing cell NAND3X1
Writing cell XNOR2X1
Writing cell AOI22X1
Writing cell OAI22X1
Writing cell NOR3X1

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running yosys for verilog parsing and synthesis
yosys  -s aluuu.ys

/----------------------------------------------------------------------------\
|                                                                            |
|  yosys -- Yosys Open SYnthesis Suite                                       |
|                                                                            |
|  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
|                                                                            |
|  Permission to use, copy, modify, and/or distribute this software for any  |
|  purpose with or without fee is hereby granted, provided that the above    |
|  copyright notice and this permission notice appear in all copies.         |
|                                                                            |
|  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
|  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
|  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
|  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
|  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
|  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
|  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
|                                                                            |
\----------------------------------------------------------------------------/

Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `aluuu.ys' --

1. Executing Liberty frontend: /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
Imported 39 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/kor-tac/Desktop/physical/alu/source/aluuu.v
Parsing Verilog input from `/home/kor-tac/Desktop/physical/alu/source/aluuu.v' to AST representation.
Generating RTLIL representation for module `\ha'.
Generating RTLIL representation for module `\fa1'.
Generating RTLIL representation for module `\multi_10'.
/home/kor-tac/Desktop/physical/alu/source/aluuu.v:41: Warning: Identifier `\p' is implicitly declared.
Generating RTLIL representation for module `\adder_10'.
Generating RTLIL representation for module `\sub_10'.
Generating RTLIL representation for module `\comp_10'.
Generating RTLIL representation for module `\adie'.
Generating RTLIL representation for module `\orie'.
Generating RTLIL representation for module `\arilef'.
Generating RTLIL representation for module `\aririi'.
Generating RTLIL representation for module `\aluuu'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10

3.1.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10
Removed 0 unused modules.
Mapping positional arguments of cell aluuu.aR1 (aririi).
Mapping positional arguments of cell aluuu.aL1 (arilef).
Mapping positional arguments of cell aluuu.on (orie).
Mapping positional arguments of cell aluuu.an (adie).
Mapping positional arguments of cell aluuu.c1 (comp_10).
Mapping positional arguments of cell aluuu.ss1 (sub_10).
Mapping positional arguments of cell aluuu.a1 (adder_10).
Mapping positional arguments of cell aluuu.m1 (multi_10).
Mapping positional arguments of cell sub_10.f9 (fa1).
Mapping positional arguments of cell sub_10.f8 (fa1).
Mapping positional arguments of cell sub_10.f7 (fa1).
Mapping positional arguments of cell sub_10.f6 (fa1).
Mapping positional arguments of cell sub_10.f5 (fa1).
Mapping positional arguments of cell sub_10.f4 (fa1).
Mapping positional arguments of cell sub_10.f3 (fa1).
Mapping positional arguments of cell sub_10.f2 (fa1).
Mapping positional arguments of cell sub_10.f1 (fa1).
Mapping positional arguments of cell sub_10.f0 (fa1).
Mapping positional arguments of cell adder_10.f9 (fa1).
Mapping positional arguments of cell adder_10.f8 (fa1).
Mapping positional arguments of cell adder_10.f7 (fa1).
Mapping positional arguments of cell adder_10.f6 (fa1).
Mapping positional arguments of cell adder_10.f5 (fa1).
Mapping positional arguments of cell adder_10.f4 (fa1).
Mapping positional arguments of cell adder_10.f3 (fa1).
Mapping positional arguments of cell adder_10.f2 (fa1).
Mapping positional arguments of cell adder_10.f1 (fa1).
Mapping positional arguments of cell adder_10.f0 (fa1).
Mapping positional arguments of cell multi_10.h18 (fa1).
Mapping positional arguments of cell multi_10.f74 (fa1).
Mapping positional arguments of cell multi_10.f73 (fa1).
Mapping positional arguments of cell multi_10.f72 (fa1).
Mapping positional arguments of cell multi_10.f71 (fa1).
Mapping positional arguments of cell multi_10.f70 (fa1).
Mapping positional arguments of cell multi_10.f69 (fa1).
Mapping positional arguments of cell multi_10.f68 (fa1).
Mapping positional arguments of cell multi_10.f67 (fa1).
Mapping positional arguments of cell multi_10.h17 (ha).
Mapping positional arguments of cell multi_10.h16 (fa1).
Mapping positional arguments of cell multi_10.f66 (fa1).
Mapping positional arguments of cell multi_10.f65 (fa1).
Mapping positional arguments of cell multi_10.f64 (fa1).
Mapping positional arguments of cell multi_10.f63 (fa1).
Mapping positional arguments of cell multi_10.f62 (fa1).
Mapping positional arguments of cell multi_10.f61 (fa1).
Mapping positional arguments of cell multi_10.f60 (fa1).
Mapping positional arguments of cell multi_10.f59 (fa1).
Mapping positional arguments of cell multi_10.h15 (ha).
Mapping positional arguments of cell multi_10.h14 (fa1).
Mapping positional arguments of cell multi_10.f58 (fa1).
Mapping positional arguments of cell multi_10.f57 (fa1).
Mapping positional arguments of cell multi_10.f56 (fa1).
Mapping positional arguments of cell multi_10.f53 (fa1).
Mapping positional arguments of cell multi_10.f52 (fa1).
Mapping positional arguments of cell multi_10.f51 (fa1).
Mapping positional arguments of cell multi_10.f50 (fa1).
Mapping positional arguments of cell multi_10.f49 (fa1).
Mapping positional arguments of cell multi_10.h13 (ha).
Mapping positional arguments of cell multi_10.h12 (fa1).
Mapping positional arguments of cell multi_10.f48 (fa1).
Mapping positional arguments of cell multi_10.f47 (fa1).
Mapping positional arguments of cell multi_10.f46 (fa1).
Mapping positional arguments of cell multi_10.f45 (fa1).
Mapping positional arguments of cell multi_10.f44 (fa1).
Mapping positional arguments of cell multi_10.f43 (fa1).
Mapping positional arguments of cell multi_10.f42 (fa1).
Mapping positional arguments of cell multi_10.f41 (fa1).
Mapping positional arguments of cell multi_10.h11 (ha).
Mapping positional arguments of cell multi_10.h10 (fa1).
Mapping positional arguments of cell multi_10.f40 (fa1).
Mapping positional arguments of cell multi_10.f39 (fa1).
Mapping positional arguments of cell multi_10.f38 (fa1).
Mapping positional arguments of cell multi_10.f37 (fa1).
Mapping positional arguments of cell multi_10.f36 (fa1).
Mapping positional arguments of cell multi_10.f35 (fa1).
Mapping positional arguments of cell multi_10.f34 (fa1).
Mapping positional arguments of cell multi_10.f33 (fa1).
Mapping positional arguments of cell multi_10.h9 (ha).
Mapping positional arguments of cell multi_10.h8 (fa1).
Mapping positional arguments of cell multi_10.f32 (fa1).
Mapping positional arguments of cell multi_10.f31 (fa1).
Mapping positional arguments of cell multi_10.f30 (fa1).
Mapping positional arguments of cell multi_10.f29 (fa1).
Mapping positional arguments of cell multi_10.f28 (fa1).
Mapping positional arguments of cell multi_10.f27 (fa1).
Mapping positional arguments of cell multi_10.f26 (fa1).
Mapping positional arguments of cell multi_10.f25 (fa1).
Mapping positional arguments of cell multi_10.h7 (ha).
Mapping positional arguments of cell multi_10.h6 (fa1).
Mapping positional arguments of cell multi_10.f24 (fa1).
Mapping positional arguments of cell multi_10.f23 (fa1).
Mapping positional arguments of cell multi_10.f22 (fa1).
Mapping positional arguments of cell multi_10.f21 (fa1).
Mapping positional arguments of cell multi_10.f20 (fa1).
Mapping positional arguments of cell multi_10.f19 (fa1).
Mapping positional arguments of cell multi_10.f18 (fa1).
Mapping positional arguments of cell multi_10.f17 (fa1).
Mapping positional arguments of cell multi_10.h5 (ha).
Mapping positional arguments of cell multi_10.h4 (fa1).
Mapping positional arguments of cell multi_10.f16 (fa1).
Mapping positional arguments of cell multi_10.f15 (fa1).
Mapping positional arguments of cell multi_10.f14 (fa1).
Mapping positional arguments of cell multi_10.f13 (fa1).
Mapping positional arguments of cell multi_10.f12 (fa1).
Mapping positional arguments of cell multi_10.f11 (fa1).
Mapping positional arguments of cell multi_10.f10 (fa1).
Mapping positional arguments of cell multi_10.f9 (fa1).
Mapping positional arguments of cell multi_10.h3 (ha).
Mapping positional arguments of cell multi_10.h2 (ha).
Mapping positional arguments of cell multi_10.f8 (fa1).
Mapping positional arguments of cell multi_10.f7 (fa1).
Mapping positional arguments of cell multi_10.f6 (fa1).
Mapping positional arguments of cell multi_10.f5 (fa1).
Mapping positional arguments of cell multi_10.f4 (fa1).
Mapping positional arguments of cell multi_10.f3 (fa1).
Mapping positional arguments of cell multi_10.f2 (fa1).
Mapping positional arguments of cell multi_10.f1 (fa1).
Mapping positional arguments of cell multi_10.h1 (ha).
Mapping positional arguments of cell fa1.h2 (ha).
Mapping positional arguments of cell fa1.h1 (ha).
Warning: Resizing cell port aluuu.a1.sum from 10 bits to 11 bits.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed 1 dead cases from process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Marked 1 switch rules as full_case in process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Removed a total of 1 dead cases.

3.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

3.2.4. Executing PROC_INIT pass (extract init attributes).

3.2.5. Executing PROC_ARST pass (detect async resets in processes).

3.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~1 debug messages>

3.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
1/1: $1\y[19:0]

3.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\aluuu.\y' from process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.

3.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Removing empty process `aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Cleaned up 1 empty switch.

3.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module aririi.
<suppressed ~1 debug messages>
Optimizing module arilef.
<suppressed ~1 debug messages>
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
<suppressed ~1 debug messages>
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
Optimizing module aririi.
Optimizing module arilef.
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \sub_10..
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Removed 0 unused cells and 16 unused wires.
<suppressed ~10 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
<suppressed ~486 debug messages>
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 162 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.6. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 162 unused wires.
<suppressed ~1 debug messages>

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.16. Finished OPT passes. (There is nothing left to do.)

3.7. Executing FSM pass (extract and optimize FSM).

3.7.1. Executing FSM_DETECT pass (finding FSMs in design).

3.7.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.7.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.7.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.7.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.7.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.8. Executing OPT pass (performing simple optimizations).

3.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.6. Executing OPT_DFF pass (perform DFF optimizations).

3.8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.9. Finished OPT passes. (There is nothing left to do.)

3.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$373_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$374_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell aluuu.$procmux$375_CMP0 ($eq).

3.10. Executing PEEPOPT pass (run peephole optimizers).

3.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.12. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module adder_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module adie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aluuu:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arilef:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aririi:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module comp_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module fa1:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module ha:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module multi_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module orie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module sub_10:
created 0 $alu and 0 $macc cells.

3.13. Executing SHARE pass (SAT-based resource sharing).

3.14. Executing OPT pass (performing simple optimizations).

3.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.6. Executing OPT_DFF pass (perform DFF optimizations).

3.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.9. Finished OPT passes. (There is nothing left to do.)

3.15. Executing MEMORY pass.

3.15.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.15.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.15.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.15.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.15.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.15.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.15.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.15.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.17. Executing OPT pass (performing simple optimizations).

3.17.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.17.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.17.3. Executing OPT_DFF pass (perform DFF optimizations).

3.17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

3.17.5. Finished fast OPT passes.

3.18. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

3.19. Executing OPT pass (performing simple optimizations).

3.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.6. Executing OPT_SHARE pass.

3.19.7. Executing OPT_DFF pass (perform DFF optimizations).

3.19.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.19.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.10. Finished OPT passes. (There is nothing left to do.)

3.20. Executing TECHMAP pass (map to technology primitives).

3.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.20.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $xnor.
Using extmapper simplemap for cells of type $eq.
Using template $paramod$43fa60c46e83442767389184ae02572e3838275f\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $mux.
No more expansions possible.
<suppressed ~324 debug messages>

3.21. Executing OPT pass (performing simple optimizations).

3.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~153 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
<suppressed ~36 debug messages>
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 12 cells.

3.21.3. Executing OPT_DFF pass (perform DFF optimizations).

3.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 125 unused wires.
<suppressed ~1 debug messages>

3.21.5. Finished fast OPT passes.

3.22. Executing ABC pass (technology mapping using ABC).

3.22.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.2.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 175 gates and 263 wires to a netlist network with 87 inputs and 20 outputs.

3.22.3.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.3.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:              NAND cells:        3
ABC RESULTS:                OR cells:       61
ABC RESULTS:               MUX cells:       10
ABC RESULTS:             ORNOT cells:       14
ABC RESULTS:            ANDNOT cells:       77
ABC RESULTS:        internal signals:      156
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

3.22.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 95 gates and 115 wires to a netlist network with 20 inputs and 3 outputs.

3.22.6.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.6.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       10
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:       18
ABC RESULTS:            ANDNOT cells:       20
ABC RESULTS:                OR cells:       44
ABC RESULTS:        internal signals:       92
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

3.22.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

3.22.7.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.7.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

3.22.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

3.22.8.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.8.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

3.22.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

3.22.9.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

3.22.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.10.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.10.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.

3.22.11.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.11.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:       10
Removing temp directory.

3.23. Executing OPT pass (performing simple optimizations).

3.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.23.3. Executing OPT_DFF pass (perform DFF optimizations).

3.23.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 469 unused wires.
<suppressed ~8 debug messages>

3.23.5. Finished fast OPT passes.

3.24. Executing HIERARCHY pass (managing design hierarchy).

3.24.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10

3.24.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10
Removed 0 unused modules.

3.25. Printing statistics.

=== adder_10 ===

Number of wires:                  4
Number of wire bits:             40
Number of public wires:           4
Number of public wire bits:      40
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
fa1                            10

=== adie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_AND_                         10

=== aluuu ===

Number of wires:                160
Number of wire bits:            275
Number of public wires:          12
Number of public wire bits:     127
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                175
$_ANDNOT_                      77
$_AND_                          1
$_MUX_                         10
$_NAND_                         3
$_NOT_                          1
$_ORNOT_                       14
$_OR_                          61
adder_10                        1
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
orie                            1
sub_10                          1

=== arilef ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== aririi ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== comp_10 ===

Number of wires:                 93
Number of wire bits:            113
Number of public wires:           3
Number of public wire bits:      23
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 93
$_ANDNOT_                      20
$_NOR_                          1
$_NOT_                         18
$_OR_                          44
$_XOR_                         10

=== fa1 ===

Number of wires:                  8
Number of wire bits:              8
Number of public wires:           8
Number of public wire bits:       8
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  3
$_OR_                           1
ha                              2

=== ha ===

Number of wires:                  4
Number of wire bits:              4
Number of public wires:           4
Number of public wire bits:       4
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  2
/usr/local/share/qflow/scripts/spi2xspice.py:32: SyntaxWarning: invalid escape sequence '\*'
$_AND_                          1
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
$_XOR_                          1
/usr/local/share/qflow/scripts/spi2xspice.py:33: SyntaxWarning: invalid escape sequence '\*'

subrex  = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
=== multi_10 ===
/usr/local/share/qflow/scripts/spi2xspice.py:34: SyntaxWarning: invalid escape sequence '\*'

endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
Number of wires:                264
/usr/local/share/qflow/scripts/spi2xspice.py:35: SyntaxWarning: invalid escape sequence '\*'
Number of wire bits:            301
comrex  = re.compile('^[\*]+.*$', re.IGNORECASE)
Number of public wires:         165
/usr/local/share/qflow/scripts/spi2xspice.py:96: SyntaxWarning: invalid escape sequence '\)'
Number of public wire bits:     202
imprex = re.compile('([10\)])[ \t]+([10\(])')
Number of memories:               0
/usr/local/share/qflow/scripts/spi2xspice.py:97: SyntaxWarning: invalid escape sequence '\)'
Number of memory bits:            0
primerex = re.compile('([10\)])[ \t]*\'')
Number of processes:              0
/usr/local/share/qflow/scripts/spi2xspice.py:143: SyntaxWarning: invalid escape sequence '\g'
Number of cells:                190
psubs = imprex.sub('\g<1>&\g<2>', psubs)
$_AND_                        100
/usr/local/share/qflow/scripts/spi2xspice.py:208: SyntaxWarning: invalid escape sequence '\*'
fa1                            80
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
ha                             10
/usr/local/share/qflow/scripts/spi2xspice.py:209: SyntaxWarning: invalid escape sequence '\*'

subrex = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
=== orie ===
/usr/local/share/qflow/scripts/spi2xspice.py:211: SyntaxWarning: invalid escape sequence '\*'

comrex = re.compile('^[\*]+.*$', re.IGNORECASE)
Number of wires:                  3
/usr/local/share/qflow/scripts/spi2xspice.py:212: SyntaxWarning: invalid escape sequence '\*'
Number of wire bits:             30
specrex = re.compile('^[\*]+This file may contain array delimiters', re.IGNORECASE)
Number of public wires:           3
/usr/local/share/qflow/scripts/spi2xspice.py:213: SyntaxWarning: invalid escape sequence '\*'
Number of public wire bits:      30
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
Number of memories:               0
/usr/local/share/qflow/scripts/spi2xspice.py:214: SyntaxWarning: invalid escape sequence '\*'
Number of memory bits:            0
endrex = re.compile('^[^\*]*[ \t]*.end.*$', re.IGNORECASE)
Number of processes:              0
/usr/local/share/qflow/scripts/spi2xspice.py:664: SyntaxWarning: invalid escape sequence '\('
Number of cells:                 10
outparenrex = re.compile('^[ \t]*\([ \t]*(.+)[ \t]*\)[ \t]*$')
$_OR_                          10
/usr/local/share/qflow/scripts/spi2xspice.py:665: SyntaxWarning: invalid escape sequence '\('

parenrex = re.compile('\([ \t]*([^ \t\)|&~^]+)[ \t]*\)')
=== sub_10 ===
/usr/local/share/qflow/scripts/spi2xspice.py:668: SyntaxWarning: invalid escape sequence '\g'

pstring = outparenrex.sub('\g<1>', pstring)
Number of wires:                  5
/usr/local/share/qflow/scripts/spi2xspice.py:669: SyntaxWarning: invalid escape sequence '\g'
Number of wire bits:             51
pstring = parenrex.sub('\g<1>', pstring)
Number of public wires:           5
/usr/local/share/qflow/scripts/spi2xspice.py:670: SyntaxWarning: invalid escape sequence '\g'
Number of public wire bits:      51
pstring = primerex.sub('~\g<1>', pstring)
Number of memories:               0
/usr/local/share/qflow/scripts/spi2xspice.py:678: SyntaxWarning: invalid escape sequence '\('
Number of memory bits:            0
cellrex  = re.compile('[ \t]*cell[ \t]*\(([^)]+)\)')
Number of processes:              0
/usr/local/share/qflow/scripts/spi2xspice.py:679: SyntaxWarning: invalid escape sequence '\('
Number of cells:                 20
pinrex   = re.compile('[ \t]*pin[ \t]*\(([^)]+)\)')
$_NOT_                         10
/usr/local/share/qflow/scripts/spi2xspice.py:680: SyntaxWarning: invalid escape sequence '\('
fa1                            10
busrex   = re.compile('[ \t]*bus[ \t]*\(([^)]+)\)')

/usr/local/share/qflow/scripts/spi2xspice.py:681: SyntaxWarning: invalid escape sequence '\('
=== design hierarchy ===
lat1rex  = re.compile('[ \t]*latch[ \t]*\(([^)]+)\)')

/usr/local/share/qflow/scripts/spi2xspice.py:682: SyntaxWarning: invalid escape sequence '\('
aluuu                             1
lat2rex  = re.compile('[ \t]*latch[ \t]*\(([^, \t]+)[ \t]*,[ \t]*([^),]+)\)')
adder_10                        1
/usr/local/share/qflow/scripts/spi2xspice.py:683: SyntaxWarning: invalid escape sequence '\('
fa1                          10
ff1rex   = re.compile('[ \t]*ff[ \t]*\(([^)]+)\)')
ha                          2
/usr/local/share/qflow/scripts/spi2xspice.py:684: SyntaxWarning: invalid escape sequence '\('
adie                            1
ff2rex   = re.compile('[ \t]*ff[ \t]*\(([^, \t]+)[ \t]*,[ \t]*([^),]+)\)')
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
fa1                          80
ha                          2
ha                           10
orie                            1
sub_10                          1
fa1                          10
ha                          2

Number of wires:               2176
Number of wire bits:           2520
Number of public wires:        1839
Number of public wire bits:    2183
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                910
$_ANDNOT_                      97
$_AND_                        321
$_MUX_                         10
$_NAND_                         3
$_NOR_                          1
$_NOT_                         29
$_ORNOT_                       14
$_OR_                         215
$_XOR_                        220

3.26. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

4. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
cell DFFNEGX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_N_.
cell DFFPOSX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_P_.
cell DFFSR (noninv, pins=5, area=704.00) is a direct match for cell type $_DFFSR_PNN_.
final dff cell mappings:
\DFFNEGX1 _DFF_N_ (.CLK( C), .D( D), .Q( Q));
\DFFPOSX1 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
unmapped dff cell: $_DFF_NN0_
unmapped dff cell: $_DFF_NN1_
unmapped dff cell: $_DFF_NP0_
unmapped dff cell: $_DFF_NP1_
unmapped dff cell: $_DFF_PN0_
unmapped dff cell: $_DFF_PN1_

LEF Read, Line 135: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 136: NOTE:  Old format VIARULE ignored.
Qflow project setup
LEF Read, Line 140: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 141: NOTE:  Old format VIARULE ignored.

LEF Read, Line 151: NOTE:  Old format VIARULE ignored.
Technology set to osu035 from existing qflow_vars.sh file
LEF Read, Line 152: NOTE:  Old format VIARULE ignored.
Regenerating files for existing project aluuu
LEF Read, Line 156: NOTE:  Old format VIARULE ignored.
Qrouter detail maze router version 1.4.71.T
LEF Read, Line 157: NOTE:  Old format VIARULE ignored.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
LEF Read, Line 167: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site corner (ignored)
LEF Read, Line 168: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site IO (ignored)
LEF Read, Line 172: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site core (ignored)
LEF Read, Line 173: NOTE:  Old format VIARULE ignored.
LEF read: Processed 3179 lines.
LEF Read: encountered 0 errors and 12 warnings total.
Vertical route layer at non-minimum pitch 3.2.  Using smaller pitch 1.6, will route on 1-of-2 tracks for layer metal4.
Running blif2cel to generate input files for graywolf
blif2cel.tcl --blif /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif  --lef  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef --cel /home/kor-tac/Desktop/physical/alu/layout/aluuu.cel
No aluuu.cel1 file found for project. . . no partial blockages to apply to layout.
No aluuu.cel2 file found for project. . . continuing without pin placement hints
Running GrayWolf placement
graywolf  aluuu
Running getfillcell to determine cell to use for fill.
getfillcell.tcl aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Using cell FILL for fill
Running place2def to translate graywolf output to DEF format.
place2def.tcl aluuu FILL
Running addspacers to generate power stripes and align cell right edge
addspacers.tcl  -stripe 5.0 150.0 PG aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Running arrangepins to adjust pin positions for optimal routing.
arrangepins.tcl  aluuu
Reading info file aluuu.info. . .
Reading DEF file aluuu.def. . .
Recalculating pin positions
Writing DEF file aluuu_mod.def. . .
Done with arrangepins.tcl
blifanno.tcl /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif aluuu.def /home/kor-tac/Desktop/physical/alu/synthesis/aluuu_anno.blif
Generating RTL verilog and SPICE netlist file in directory
/home/kor-tac/Desktop/physical/alu/synthesis
Files:
Verilog: /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.rtl.v
Verilog: /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.rtlnopwr.v
Verilog: /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.rtlbb.v
Spice:   /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.spc
Copying aluuu.rtl.v, aluuu.rtlnopwr.v, and aluuu.rtlbb.v to backups
Running blif2Verilog.

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running qrouter 1.4.71.T
qrouter -noc  -s aluuu.cfg

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  migrate_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "migrate_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
Reading DEF data from file aluuu.def.
This action cannot be undone.
LEF read, Line 20 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 20 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 21 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 21 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 22 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 22 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 26 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 26 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 27 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 27 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 28 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 28 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 32 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 32 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 33 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 33 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 34 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 34 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
Processed 3 vias total.
Processed 1231 subcell instances total.
Processed 45 pins total.
Processed 1125 nets total.
Processed 62 special nets total.
DEF read: Processed 13209 lines.
DEF Read: encountered 18 warnings total.
Generating LEF output aluuu.lef for cell aluuu:
Diagnostic:  Write LEF header for cell aluuu
Diagnostic:  Writing LEF output for cell aluuu
Diagnostic:  Scale value is 0.100000
Extracting NOR3X1 into NOR3X1.ext:
Extracting OAI22X1 into OAI22X1.ext:
Extracting AOI22X1 into AOI22X1.ext:
Extracting XNOR2X1 into XNOR2X1.ext:
Extracting NAND3X1 into NAND3X1.ext:
Extracting OAI21X1 into OAI21X1.ext:
Extracting AOI21X1 into AOI21X1.ext:
Extracting NAND2X1 into NAND2X1.ext:
Extracting INVX1 into INVX1.ext:
Extracting BUFX2 into BUFX2.ext:
Extracting FILL into FILL.ext:
Extracting OR2X2 into OR2X2.ext:
Extracting NOR2X1 into NOR2X1.ext:
Extracting AND2X2 into AND2X2.ext:
Extracting aluuu into aluuu.ext:

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl" from command line.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
aluuu: 10000 rects
aluuu: 20000 rects
aluuu: 30000 rects
aluuu: 40000 rects
aluuu: 50000 rects
Processing timestamp mismatches: FILL, NOR2X1, NOR3X1, NAND3X1, OAI21X1, INVX1, NAND2X1, BUFX2, OAI22X1, OR2X2, AND2X2, AOI21X1, AOI22X1, XNOR2X1.

--------------------------------
Qflow project setup
--------------------------------

--------------------------------
Qflow project setup
--------------------------------

Technology set to gscl45nm from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running yosys for verilog parsing and synthesis
yosys  -s aluuu.ys

/----------------------------------------------------------------------------\
|                                                                            |
|  yosys -- Yosys Open SYnthesis Suite                                       |
|                                                                            |
|  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
|                                                                            |
|  Permission to use, copy, modify, and/or distribute this software for any  |
|  purpose with or without fee is hereby granted, provided that the above    |
|  copyright notice and this permission notice appear in all copies.         |
|                                                                            |
|  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
|  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
|  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
|  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
|  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
|  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
|  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
|                                                                            |
\----------------------------------------------------------------------------/

Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `aluuu.ys' --

1. Executing Liberty frontend: /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib
Imported 31 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/kor-tac/Desktop/physical/alu/source/aluuu.v
Parsing Verilog input from `/home/kor-tac/Desktop/physical/alu/source/aluuu.v' to AST representation.
Generating RTLIL representation for module `\ha'.
Generating RTLIL representation for module `\fa1'.
Generating RTLIL representation for module `\multi_10'.
/home/kor-tac/Desktop/physical/alu/source/aluuu.v:41: Warning: Identifier `\p' is implicitly declared.
Generating RTLIL representation for module `\adder_10'.
Generating RTLIL representation for module `\sub_10'.
Generating RTLIL representation for module `\comp_10'.
Generating RTLIL representation for module `\adie'.
Generating RTLIL representation for module `\orie'.
Generating RTLIL representation for module `\arilef'.
Generating RTLIL representation for module `\aririi'.
Generating RTLIL representation for module `\aluuu'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10

3.1.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10
Removed 0 unused modules.
Mapping positional arguments of cell aluuu.aR1 (aririi).
Mapping positional arguments of cell aluuu.aL1 (arilef).
Mapping positional arguments of cell aluuu.on (orie).
Mapping positional arguments of cell aluuu.an (adie).
Mapping positional arguments of cell aluuu.c1 (comp_10).
Mapping positional arguments of cell aluuu.ss1 (sub_10).
Mapping positional arguments of cell aluuu.a1 (adder_10).
Mapping positional arguments of cell aluuu.m1 (multi_10).
Mapping positional arguments of cell sub_10.f9 (fa1).
Mapping positional arguments of cell sub_10.f8 (fa1).
Mapping positional arguments of cell sub_10.f7 (fa1).
Mapping positional arguments of cell sub_10.f6 (fa1).
Mapping positional arguments of cell sub_10.f5 (fa1).
Mapping positional arguments of cell sub_10.f4 (fa1).
Mapping positional arguments of cell sub_10.f3 (fa1).
Mapping positional arguments of cell sub_10.f2 (fa1).
Mapping positional arguments of cell sub_10.f1 (fa1).
Mapping positional arguments of cell sub_10.f0 (fa1).
Mapping positional arguments of cell adder_10.f9 (fa1).
Mapping positional arguments of cell adder_10.f8 (fa1).
Mapping positional arguments of cell adder_10.f7 (fa1).
Mapping positional arguments of cell adder_10.f6 (fa1).
Mapping positional arguments of cell adder_10.f5 (fa1).
Mapping positional arguments of cell adder_10.f4 (fa1).
Mapping positional arguments of cell adder_10.f3 (fa1).
Mapping positional arguments of cell adder_10.f2 (fa1).
Mapping positional arguments of cell adder_10.f1 (fa1).
Mapping positional arguments of cell adder_10.f0 (fa1).
Mapping positional arguments of cell multi_10.h18 (fa1).
Mapping positional arguments of cell multi_10.f74 (fa1).
Mapping positional arguments of cell multi_10.f73 (fa1).
Mapping positional arguments of cell multi_10.f72 (fa1).
Mapping positional arguments of cell multi_10.f71 (fa1).
Mapping positional arguments of cell multi_10.f70 (fa1).
Mapping positional arguments of cell multi_10.f69 (fa1).
Mapping positional arguments of cell multi_10.f68 (fa1).
Mapping positional arguments of cell multi_10.f67 (fa1).
Mapping positional arguments of cell multi_10.h17 (ha).
Mapping positional arguments of cell multi_10.h16 (fa1).
Mapping positional arguments of cell multi_10.f66 (fa1).
Mapping positional arguments of cell multi_10.f65 (fa1).
Mapping positional arguments of cell multi_10.f64 (fa1).
Mapping positional arguments of cell multi_10.f63 (fa1).
Mapping positional arguments of cell multi_10.f62 (fa1).
Mapping positional arguments of cell multi_10.f61 (fa1).
Mapping positional arguments of cell multi_10.f60 (fa1).
Mapping positional arguments of cell multi_10.f59 (fa1).
Mapping positional arguments of cell multi_10.h15 (ha).
Mapping positional arguments of cell multi_10.h14 (fa1).
Mapping positional arguments of cell multi_10.f58 (fa1).
Mapping positional arguments of cell multi_10.f57 (fa1).
Mapping positional arguments of cell multi_10.f56 (fa1).
Mapping positional arguments of cell multi_10.f53 (fa1).
Mapping positional arguments of cell multi_10.f52 (fa1).
Mapping positional arguments of cell multi_10.f51 (fa1).
Mapping positional arguments of cell multi_10.f50 (fa1).
Mapping positional arguments of cell multi_10.f49 (fa1).
Mapping positional arguments of cell multi_10.h13 (ha).
Mapping positional arguments of cell multi_10.h12 (fa1).
Mapping positional arguments of cell multi_10.f48 (fa1).
Mapping positional arguments of cell multi_10.f47 (fa1).
Mapping positional arguments of cell multi_10.f46 (fa1).
Mapping positional arguments of cell multi_10.f45 (fa1).
Mapping positional arguments of cell multi_10.f44 (fa1).
Mapping positional arguments of cell multi_10.f43 (fa1).
Mapping positional arguments of cell multi_10.f42 (fa1).
Mapping positional arguments of cell multi_10.f41 (fa1).
Mapping positional arguments of cell multi_10.h11 (ha).
Mapping positional arguments of cell multi_10.h10 (fa1).
Mapping positional arguments of cell multi_10.f40 (fa1).
Mapping positional arguments of cell multi_10.f39 (fa1).
Mapping positional arguments of cell multi_10.f38 (fa1).
Mapping positional arguments of cell multi_10.f37 (fa1).
Mapping positional arguments of cell multi_10.f36 (fa1).
Mapping positional arguments of cell multi_10.f35 (fa1).
Mapping positional arguments of cell multi_10.f34 (fa1).
Mapping positional arguments of cell multi_10.f33 (fa1).
Mapping positional arguments of cell multi_10.h9 (ha).
Mapping positional arguments of cell multi_10.h8 (fa1).
Mapping positional arguments of cell multi_10.f32 (fa1).
Mapping positional arguments of cell multi_10.f31 (fa1).
Mapping positional arguments of cell multi_10.f30 (fa1).
Mapping positional arguments of cell multi_10.f29 (fa1).
Mapping positional arguments of cell multi_10.f28 (fa1).
Mapping positional arguments of cell multi_10.f27 (fa1).
Mapping positional arguments of cell multi_10.f26 (fa1).
Mapping positional arguments of cell multi_10.f25 (fa1).
Mapping positional arguments of cell multi_10.h7 (ha).
Mapping positional arguments of cell multi_10.h6 (fa1).
Mapping positional arguments of cell multi_10.f24 (fa1).
Mapping positional arguments of cell multi_10.f23 (fa1).
Mapping positional arguments of cell multi_10.f22 (fa1).
Mapping positional arguments of cell multi_10.f21 (fa1).
Mapping positional arguments of cell multi_10.f20 (fa1).
Mapping positional arguments of cell multi_10.f19 (fa1).
Mapping positional arguments of cell multi_10.f18 (fa1).
Mapping positional arguments of cell multi_10.f17 (fa1).
Mapping positional arguments of cell multi_10.h5 (ha).
Mapping positional arguments of cell multi_10.h4 (fa1).
Mapping positional arguments of cell multi_10.f16 (fa1).
Mapping positional arguments of cell multi_10.f15 (fa1).
Mapping positional arguments of cell multi_10.f14 (fa1).
Mapping positional arguments of cell multi_10.f13 (fa1).
Mapping positional arguments of cell multi_10.f12 (fa1).
Mapping positional arguments of cell multi_10.f11 (fa1).
Mapping positional arguments of cell multi_10.f10 (fa1).
Mapping positional arguments of cell multi_10.f9 (fa1).
Mapping positional arguments of cell multi_10.h3 (ha).
Mapping positional arguments of cell multi_10.h2 (ha).
Mapping positional arguments of cell multi_10.f8 (fa1).
Mapping positional arguments of cell multi_10.f7 (fa1).
Mapping positional arguments of cell multi_10.f6 (fa1).
Mapping positional arguments of cell multi_10.f5 (fa1).
Mapping positional arguments of cell multi_10.f4 (fa1).
Mapping positional arguments of cell multi_10.f3 (fa1).
Mapping positional arguments of cell multi_10.f2 (fa1).
Mapping positional arguments of cell multi_10.f1 (fa1).
Mapping positional arguments of cell multi_10.h1 (ha).
Mapping positional arguments of cell fa1.h2 (ha).
Mapping positional arguments of cell fa1.h1 (ha).
Warning: Resizing cell port aluuu.a1.sum from 10 bits to 11 bits.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed 1 dead cases from process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Marked 1 switch rules as full_case in process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Removed a total of 1 dead cases.

3.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

3.2.4. Executing PROC_INIT pass (extract init attributes).

3.2.5. Executing PROC_ARST pass (detect async resets in processes).

3.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~1 debug messages>

3.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
1/1: $1\y[19:0]

3.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\aluuu.\y' from process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.

3.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Removing empty process `aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Cleaned up 1 empty switch.

3.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module aririi.
<suppressed ~1 debug messages>
Optimizing module arilef.
<suppressed ~1 debug messages>
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
<suppressed ~1 debug messages>
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
Optimizing module aririi.
Optimizing module arilef.
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \sub_10..
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Removed 0 unused cells and 16 unused wires.
<suppressed ~10 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
<suppressed ~486 debug messages>
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 162 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.6. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 162 unused wires.
<suppressed ~1 debug messages>

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.16. Finished OPT passes. (There is nothing left to do.)

3.7. Executing FSM pass (extract and optimize FSM).

3.7.1. Executing FSM_DETECT pass (finding FSMs in design).

3.7.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.7.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.7.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.7.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.7.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.8. Executing OPT pass (performing simple optimizations).

3.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.6. Executing OPT_DFF pass (perform DFF optimizations).

3.8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.9. Finished OPT passes. (There is nothing left to do.)

3.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$373_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$374_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell aluuu.$procmux$375_CMP0 ($eq).

3.10. Executing PEEPOPT pass (run peephole optimizers).

3.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.12. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module adder_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module adie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aluuu:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arilef:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aririi:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module comp_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module fa1:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module ha:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module multi_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module orie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module sub_10:
created 0 $alu and 0 $macc cells.

3.13. Executing SHARE pass (SAT-based resource sharing).

3.14. Executing OPT pass (performing simple optimizations).

3.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.6. Executing OPT_DFF pass (perform DFF optimizations).

3.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.9. Finished OPT passes. (There is nothing left to do.)

3.15. Executing MEMORY pass.

3.15.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.15.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.15.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.15.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.15.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.15.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.15.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.15.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.17. Executing OPT pass (performing simple optimizations).

3.17.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.17.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.17.3. Executing OPT_DFF pass (perform DFF optimizations).

3.17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

3.17.5. Finished fast OPT passes.

3.18. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

3.19. Executing OPT pass (performing simple optimizations).

3.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.6. Executing OPT_SHARE pass.

3.19.7. Executing OPT_DFF pass (perform DFF optimizations).

3.19.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.19.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.10. Finished OPT passes. (There is nothing left to do.)

3.20. Executing TECHMAP pass (map to technology primitives).

3.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.20.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $xnor.
Using extmapper simplemap for cells of type $eq.
Using template $paramod$43fa60c46e83442767389184ae02572e3838275f\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $mux.
No more expansions possible.
<suppressed ~324 debug messages>

3.21. Executing OPT pass (performing simple optimizations).

3.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~153 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
<suppressed ~36 debug messages>
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 12 cells.

3.21.3. Executing OPT_DFF pass (perform DFF optimizations).

3.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 125 unused wires.
<suppressed ~1 debug messages>

3.21.5. Finished fast OPT passes.

3.22. Executing ABC pass (technology mapping using ABC).

3.22.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.2.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 175 gates and 263 wires to a netlist network with 87 inputs and 20 outputs.

3.22.3.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.3.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:              NAND cells:        3
ABC RESULTS:                OR cells:       61
ABC RESULTS:               MUX cells:       10
ABC RESULTS:             ORNOT cells:       14
ABC RESULTS:            ANDNOT cells:       77
ABC RESULTS:        internal signals:      156
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

3.22.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 95 gates and 115 wires to a netlist network with 20 inputs and 3 outputs.

3.22.6.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.6.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       10
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:       18
ABC RESULTS:            ANDNOT cells:       20
ABC RESULTS:                OR cells:       44
ABC RESULTS:        internal signals:       92
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

3.22.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

3.22.7.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.7.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

3.22.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

3.22.8.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.8.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

3.22.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

3.22.9.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

3.22.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.10.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.10.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.

3.22.11.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.11.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:       10
Removing temp directory.

3.23. Executing OPT pass (performing simple optimizations).

3.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.23.3. Executing OPT_DFF pass (perform DFF optimizations).

3.23.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 469 unused wires.
<suppressed ~8 debug messages>

3.23.5. Finished fast OPT passes.

3.24. Executing HIERARCHY pass (managing design hierarchy).

3.24.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10

3.24.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10
Removed 0 unused modules.

3.25. Printing statistics.

=== adder_10 ===

Number of wires:                  4
Number of wire bits:             40
Number of public wires:           4
Number of public wire bits:      40
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
fa1                            10

=== adie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_AND_                         10

=== aluuu ===

Number of wires:                160
Number of wire bits:            275
Number of public wires:          12
Number of public wire bits:     127
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                175
$_ANDNOT_                      77
$_AND_                          1
$_MUX_                         10
$_NAND_                         3
$_NOT_                          1
$_ORNOT_                       14
$_OR_                          61
adder_10                        1
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
orie                            1
sub_10                          1

=== arilef ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== aririi ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== comp_10 ===

Number of wires:                 93
Number of wire bits:            113
Number of public wires:           3
Number of public wire bits:      23
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 93
$_ANDNOT_                      20
$_NOR_                          1
$_NOT_                         18
$_OR_                          44
$_XOR_                         10

=== fa1 ===

Number of wires:                  8
Number of wire bits:              8
Number of public wires:           8
Number of public wire bits:       8
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  3
$_OR_                           1
ha                              2

=== ha ===

Number of wires:                  4
Number of wire bits:              4
Number of public wires:           4
Number of public wire bits:       4
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  2
$_AND_                          1
$_XOR_                          1

=== multi_10 ===

Number of wires:                264
Number of wire bits:            301
Number of public wires:         165
Number of public wire bits:     202
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                190
$_AND_                        100
fa1                            80
ha                             10

=== orie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_OR_                          10

=== sub_10 ===

Number of wires:                  5
Number of wire bits:             51
Number of public wires:           5
Number of public wire bits:      51
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 20
$_NOT_                         10
fa1                            10

=== design hierarchy ===

aluuu                             1
adder_10                        1
fa1                          10
ha                          2
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
fa1                          80
ha                          2
ha                           10
orie                            1
sub_10                          1
fa1                          10
ha                          2

Number of wires:               2176
Number of wire bits:           2520
Number of public wires:        1839
Number of public wire bits:    2183
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                910
$_ANDNOT_                      97
$_AND_                        321
$_MUX_                         10
$_NAND_                         3
$_NOR_                          1
$_NOT_                         29
$_ORNOT_                       14
$_OR_                         215
$_XOR_                        220

3.26. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

4. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
cell DFFNEGX1 (noninv, pins=3, area=7.98) is a direct match for cell type $_DFF_N_.
cell DFFPOSX1 (noninv, pins=3, area=7.98) is a direct match for cell type $_DFF_P_.
cell DFFSR (noninv, pins=5, area=10.32) is a direct match for cell type $_DFFSR_PNN_.
final dff cell mappings:
\DFFNEGX1 _DFF_N_ (.CLK( C), .D( D), .Q( Q));
\DFFPOSX1 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
unmapped dff cell: $_DFF_NN0_
unmapped dff cell: $_DFF_NN1_
unmapped dff cell: $_DFF_NP0_
unmapped dff cell: $_DFF_NP1_
unmapped dff cell: $_DFF_PN0_
unmapped dff cell: $_DFF_PN1_
unmapped dff cell: $_DFF_PP0_
unmapped dff cell: $_DFF_PP1_
unmapped dff cell: $_DFFSR_NNN_
unmapped dff cell: $_DFFSR_NNP_
unmapped dff cell: $_DFFSR_NPN_
unmapped dff cell: $_DFFSR_NPP_
\DFFSR _DFFSR_PNN_ (.CLK( C), .D( D), .Q( Q), .R( R), .S( S));
unmapped dff cell: $_DFFSR_PNP_
unmapped dff cell: $_DFFSR_PPN_
unmapped dff cell: $_DFFSR_PPP_

4.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).
Mapping DFF cells in module `\adder_10':
Mapping DFF cells in module `\adie':
Mapping DFF cells in module `\aluuu':
Mapping DFF cells in module `\arilef':
Mapping DFF cells in module `\aririi':
Mapping DFF cells in module `\comp_10':
Mapping DFF cells in module `\fa1':
Mapping DFF cells in module `\ha':
Mapping DFF cells in module `\multi_10':
Mapping DFF cells in module `\orie':
Mapping DFF cells in module `\sub_10':

5. Executing OPT pass (performing simple optimizations).

5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.

5.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

5.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.6. Executing OPT_DFF pass (perform DFF optimizations).

5.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

5.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.9. Finished OPT passes. (There is nothing left to do.)

6. Executing ABC pass (technology mapping using ABC).

6.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

6.2.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "gscl45nm" from "/usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib" has 25 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
Unexpected END statement END PROPERTYDEFINITIONS while reading section contactResistance
ABC: Memory =    0.48 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.2.2. Re-integrating ABC results.
ABC RESULTS:            AND2X2 cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

6.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 167 gates and 254 wires to a netlist network with 87 inputs and 20 outputs.

6.3.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "gscl45nm" from "/usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib" has 25 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.48 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.3.2. Re-integrating ABC results.
ABC RESULTS:            NOR3X1 cells:        1
ABC RESULTS:             INVX1 cells:        3
ABC RESULTS:            NOR2X1 cells:        1
ABC RESULTS:             OR2X2 cells:       64
ABC RESULTS:            AND2X2 cells:       94
ABC RESULTS:        internal signals:      147
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

6.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

6.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 93 gates and 113 wires to a netlist network with 20 inputs and 3 outputs.

6.6.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "gscl45nm" from "/usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib" has 25 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.48 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.6.2. Re-integrating ABC results.
ABC RESULTS:            NOR3X1 cells:        1
ABC RESULTS:           XNOR2X1 cells:        7
ABC RESULTS:           AOI21X1 cells:        1
ABC RESULTS:            NOR2X1 cells:        8
ABC RESULTS:           NAND2X1 cells:        4
ABC RESULTS:             INVX1 cells:       19
ABC RESULTS:           AOI22X1 cells:        1
ABC RESULTS:           NAND3X1 cells:        6
ABC RESULTS:            AND2X2 cells:       26
ABC RESULTS:             OR2X2 cells:       15
ABC RESULTS:        internal signals:       90
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

6.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

6.7.1. Executing ABC.
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_lib -w /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
ABC: Library "gscl45nm" from "/usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib" has 25 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
ABC: Memory =    0.48 MB. Time =     0.00 sec
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
ABC: + strash
ABC: + scorr
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
ABC: + ifraig
ABC: + retime
ABC: + strash
ABC: + dch -f
ABC: + map -M 1
ABC: + write_blif <abc-temp-dir>/output.blif

6.7.2. Re-integrating ABC results.
ABC RESULTS:             OR2X2 cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.
/usr/local/share/qflow/scripts/spi2xspice.py:32: SyntaxWarning: invalid escape sequence '\*'

increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
6.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
/usr/local/share/qflow/scripts/spi2xspice.py:33: SyntaxWarning: invalid escape sequence '\*'
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.
subrex  = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)

/usr/local/share/qflow/scripts/spi2xspice.py:34: SyntaxWarning: invalid escape sequence '\*'
6.8.1. Executing ABC.
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
Running ABC command: "/usr/local/share/qflow/bin/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
/usr/local/share/qflow/scripts/spi2xspice.py:35: SyntaxWarning: invalid escape sequence '\*'
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
comrex  = re.compile('^[\*]+.*$', re.IGNORECASE)
ABC:
/usr/local/share/qflow/scripts/spi2xspice.py:96: SyntaxWarning: invalid escape sequence '\)'
ABC: + read_blif <abc-temp-dir>/input.blif
imprex = re.compile('([10\)])[ \t]+([10\(])')
ABC: + read_lib -w /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib
/usr/local/share/qflow/scripts/spi2xspice.py:97: SyntaxWarning: invalid escape sequence '\)'
ABC: Parsing finished successfully.  Parsing time =     0.00 sec
primerex = re.compile('([10\)])[ \t]*\'')
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFNEGX1".
/usr/local/share/qflow/scripts/spi2xspice.py:143: SyntaxWarning: invalid escape sequence '\g'
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFPOSX1".
psubs = imprex.sub('\g<1>&\g<2>', psubs)
ABC: Scl_LibertyReadGenlib() skipped sequential cell "DFFSR".
/usr/local/share/qflow/scripts/spi2xspice.py:208: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped sequential cell "LATCH".
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX1".
/usr/local/share/qflow/scripts/spi2xspice.py:209: SyntaxWarning: invalid escape sequence '\*'
ABC: Scl_LibertyReadGenlib() skipped three-state cell "TBUFX2".
subrex = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
ABC: Library "gscl45nm" from "/usr/local/share/qflow/tech/gscl45nm/gscl45nm.lib" has 25 cells (6 skipped: 4 seq; 2 tri-state; 0 no func; 0 dont_use).  Time =     0.00 sec
/usr/local/share/qflow/scripts/spi2xspice.py:211: SyntaxWarning: invalid escape sequence '\*'
ABC: Memory =    0.48 MB. Time =     0.00 sec
comrex = re.compile('^[\*]+.*$', re.IGNORECASE)
ABC: Warning: Detected 2 multi-output gates (for example, "FAX1").
/usr/local/share/qflow/scripts/spi2xspice.py:212: SyntaxWarning: invalid escape sequence '\*'
ABC: + strash
specrex = re.compile('^[\*]+This file may contain array delimiters', re.IGNORECASE)
ABC: + scorr
/usr/local/share/qflow/scripts/spi2xspice.py:213: SyntaxWarning: invalid escape sequence '\*'
ABC: Warning: The network is combinational (run "fraig" or "fraig_sweep").
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)

LEF Read, Line 399: Don't know how to parse layer "poly"
--------------------------------
LEF Read, Line 400: No layer defined for RECT.
Qflow project setup
--------------------------------

Technology set to gscl45nm from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Qrouter detail maze router version 1.4.71.T
Reading LEF data from file /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lef.
LEF file:  Defines site CoreSite (ignored)
LEF read: Processed 2937 lines.
LEF Read: encountered 2 errors and 0 warnings total.
Vertical route layer at non-minimum pitch 0.285.  Using smaller pitch 0.19, will route on 1-of-2 tracks for layer metal4.
Vertical route layer at non-minimum pitch 0.285.  Using smaller pitch 0.19, will route on 1-of-2 tracks for layer metal5.
Horizontal route layer at non-minimum pitch 0.285.  Using smaller pitch 0.19, will route on 1-of-2 tracks for layer metal5.
Vertical route layer at non-minimum pitch 0.285.  Using smaller pitch 0.19, will route on 1-of-2 tracks for layer metal6.
Vertical route layer at non-minimum pitch 0.285.  Using smaller pitch 0.19, will route on 1-of-2 tracks for layer metal7.
Horizontal route layer at non-minimum pitch 0.855.  Using smaller pitch 0.19, will route on 1-of-5 tracks for layer metal7.
Vertical route layer at non-minimum pitch 0.855.  Using smaller pitch 0.19, will route on 1-of-5 tracks for layer metal8.
Vertical route layer at non-minimum pitch 0.855.  Using smaller pitch 0.19, will route on 1-of-5 tracks for layer metal9.
Horizontal route layer at non-minimum pitch 1.71.  Using smaller pitch 0.19, will route on 1-of-9 tracks for layer metal9.
Vertical route layer at non-minimum pitch 1.71.  Using smaller pitch 0.19, will route on 1-of-9 tracks for layer metal10.
Running blif2cel to generate input files for graywolf
blif2cel.tcl --blif /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif  --lef  /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lef --cel /home/kor-tac/Desktop/physical/alu/layout/aluuu.cel
No aluuu.cel1 file found for project. . . no partial blockages to apply to layout.
No aluuu.cel2 file found for project. . . continuing without pin placement hints
Running GrayWolf placement
graywolf  aluuu
Running getfillcell to determine cell to use for fill.
Unexpected input in LEF file:  Only macro defs were expected!
getfillcell.tcl aluuu  /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lef FILL
Unexpected END statement END PROPERTYDEFINITIONS while reading section contactResistance
Using cell FILL for fill
Running place2def to translate graywolf output to DEF format.
place2def.tcl aluuu FILL
Running addspacers to generate power stripes and align cell right edge
addspacers.tcl  -stripe 1.7 50.0 PG aluuu  /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lef FILL
Running arrangepins to adjust pin positions for optimal routing.
arrangepins.tcl  aluuu
Reading info file aluuu.info. . .
Reading DEF file aluuu.def. . .
Recalculating pin positions
Writing DEF file aluuu_mod.def. . .
Done with arrangepins.tcl
blifanno.tcl /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif aluuu.def /home/kor-tac/Desktop/physical/alu/synthesis/aluuu_anno.blif

--------------------------------
Qflow project setup
--------------------------------

Technology set to gscl45nm from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running qrouter 1.4.71.T
qrouter -noc  -s aluuu.cfg
*** Running stage1 routing with defaults
Nets remaining: 900
Nets remaining: 800
Nets remaining: 700
Nets remaining: 600
Nets remaining: 500
Nets remaining: 400
Nets remaining: 300
Nets remaining: 200
Nets remaining: 100
Nets remaining: 90
Nets remaining: 80
Nets remaining: 70
Nets remaining: 60
Nets remaining: 50
Nets remaining: 40
Nets remaining: 30
Progress: Stage 1 total routes completed: 1808
Failed net routes: 4
*** Running stage2 routing with options mask 10, effort 10
Nets remaining: 4
Nets remaining: 4
Nets remaining: 3
Nets remaining: 3
Nets remaining: 3
Nets remaining: 2
Nets remaining: 1
Progress: Stage 2 total routes completed: 1858
No failed routes!
*** Running stage3 routing with defaults, 1st round
Nets remaining: 900
Nets remaining: 800
Nets remaining: 700
Nets remaining: 600
Nets remaining: 500
Nets remaining: 400
Nets remaining: 200
Nets remaining: 100
Nets remaining: 80
Progress: Stage 3 total routes completed: 3538
No failed routes!
*** Running stage3 routing with defaults, 2nd round
Nets remaining: 900


--------------------------------
Qflow project setup
--------------------------------

Technology set to gscl45nm from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  migrate_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "migrate_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Reading LEF data from file /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lef.
This action cannot be undone.
LEF read, Line 186 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 186 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 195 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 195 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 204 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 204 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 213 (Warning): Cut size for magic type "metal4" (4 x 4) does not match LEF/DEF
LEF read, Line 213 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 222 (Warning): Cut size for magic type "metal5" (6 x 6) does not match LEF/DEF
LEF read, Line 222 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 230 (Error): Don't know how to parse layer "via6"
LEF read, Line 230 (Error): Try adding this name to the LEF techfile section
LEF read, Line 231 (Error): No layer defined for RECT.
LEF read, Line 232 (Error): Don't know how to parse layer "metal7"
LEF read, Line 232 (Error): Try adding this name to the LEF techfile section
LEF read, Line 233 (Error): No layer defined for RECT.
LEF read, Line 237 (Error): Don't know how to parse layer "metal7"
LEF read, Line 237 (Error): Try adding this name to the LEF techfile section
LEF read, Line 238 (Error): No layer defined for RECT.
LEF read, Line 239 (Error): Don't know how to parse layer "via7"
LEF read, Line 239 (Error): Try adding this name to the LEF techfile section
LEF read, Line 240 (Error): No layer defined for RECT.
LEF read, Line 241 (Error): Don't know how to parse layer "metal8"
LEF read, Line 241 (Error): Try adding this name to the LEF techfile section
LEF read, Line 242 (Error): No layer defined for RECT.
LEF read, Line 246 (Error): Don't know how to parse layer "metal8"
LEF read, Line 246 (Error): Try adding this name to the LEF techfile section
LEF read, Line 247 (Error): No layer defined for RECT.
LEF read, Line 248 (Error): Don't know how to parse layer "via8"
LEF read, Line 248 (Error): Try adding this name to the LEF techfile section
LEF read, Line 249 (Error): No layer defined for RECT.
LEF read, Line 250 (Error): Don't know how to parse layer "metal9"
LEF read, Line 250 (Error): Try adding this name to the LEF techfile section
LEF read, Line 251 (Error): No layer defined for RECT.
LEF read, Line 255 (Error): Don't know how to parse layer "metal9"
LEF read, Line 255 (Error): Try adding this name to the LEF techfile section
LEF read, Line 256 (Error): No layer defined for RECT.
LEF read, Line 257 (Error): Don't know how to parse layer "via9"
LEF read, Line 257 (Error): Try adding this name to the LEF techfile section
LEF read, Line 258 (Error): No layer defined for RECT.
LEF read, Line 259 (Error): Don't know how to parse layer "metal10"
LEF read, Line 259 (Error): Try adding this name to the LEF techfile section
LEF read, Line 260 (Error): No layer defined for RECT.
LEF read, Line 267 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 267 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 276 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 276 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 285 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 285 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 294 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 294 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 303 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 303 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 314 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 314 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 324 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 324 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 334 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 334 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 344 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 344 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 354 (Warning): Cut size for magic type "(null)" (6 x 6) does not match LEF/DEF
LEF read, Line 354 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 361 (Error): Don't know how to parse layer "metal7"
LEF read, Line 361 (Error): Try adding this name to the LEF techfile section
LEF read, Line 363 (Error): Don't know how to parse layer "via6"
LEF read, Line 363 (Error): Try adding this name to the LEF techfile section
LEF read, Line 364 (Error): No layer defined for RECT.
LEF read, Line 369 (Error): Don't know how to parse layer "metal7"
LEF read, Line 369 (Error): Try adding this name to the LEF techfile section
LEF read, Line 371 (Error): Don't know how to parse layer "metal8"
LEF read, Line 371 (Error): Try adding this name to the LEF techfile section
LEF read, Line 373 (Error): Don't know how to parse layer "via7"
LEF read, Line 373 (Error): Try adding this name to the LEF techfile section
LEF read, Line 374 (Error): No layer defined for RECT.
LEF read, Line 379 (Error): Don't know how to parse layer "metal8"
LEF read, Line 379 (Error): Try adding this name to the LEF techfile section
LEF read, Line 381 (Error): Don't know how to parse layer "metal9"
LEF read, Line 381 (Error): Try adding this name to the LEF techfile section
LEF read, Line 383 (Error): Don't know how to parse layer "via8"
LEF read, Line 383 (Error): Try adding this name to the LEF techfile section
LEF read, Line 384 (Error): No layer defined for RECT.
LEF read, Line 389 (Error): Don't know how to parse layer "metal9"
LEF read, Line 389 (Error): Try adding this name to the LEF techfile section
LEF read, Line 391 (Error): Don't know how to parse layer "metal10"
LEF read, Line 391 (Error): Try adding this name to the LEF techfile section
LEF read, Line 393 (Error): Don't know how to parse layer "via9"
LEF read, Line 393 (Error): Try adding this name to the LEF techfile section
LEF read, Line 394 (Error): No layer defined for RECT.
LEF read, Line 403 (Error): Don't know how to parse layer "contact"
LEF read, Line 403 (Error): Try adding this name to the LEF techfile section
LEF read, Line 404 (Error): No layer defined for RECT.
LEF read: Processed 2937 lines.
LEF Read: encountered 62 errors total.
LEF Read: encountered 30 warnings total.
Reading DEF data from file aluuu.def.
This action cannot be undone.
LEF read, Line 24 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 24 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 28 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 28 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 32 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 32 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 36 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 36 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 40 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 40 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 44 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 44 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 48 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 48 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 52 (Error): Don't know how to parse layer "via9"
LEF read, Line 52 (Error): Try adding this name to the LEF techfile section
LEF read, Line 52 (Error): No layer defined for RECT.
LEF read, Line 53 (Error): Don't know how to parse layer "metal10"
LEF read, Line 53 (Error): Try adding this name to the LEF techfile section
LEF read, Line 53 (Error): No layer defined for RECT.
LEF read, Line 54 (Error): Don't know how to parse layer "metal9"
LEF read, Line 54 (Error): Try adding this name to the LEF techfile section
LEF read, Line 54 (Error): No layer defined for RECT.
LEF read, Line 56 (Error): Don't know how to parse layer "via8"
LEF read, Line 56 (Error): Try adding this name to the LEF techfile section
LEF read, Line 56 (Error): No layer defined for RECT.
LEF read, Line 57 (Error): Don't know how to parse layer "metal9"
LEF read, Line 57 (Error): Try adding this name to the LEF techfile section
LEF read, Line 57 (Error): No layer defined for RECT.
LEF read, Line 58 (Error): Don't know how to parse layer "metal8"
LEF read, Line 58 (Error): Try adding this name to the LEF techfile section
LEF read, Line 58 (Error): No layer defined for RECT.
LEF read, Line 60 (Error): Don't know how to parse layer "via7"
LEF read, Line 60 (Error): Try adding this name to the LEF techfile section
LEF read, Line 60 (Error): No layer defined for RECT.
LEF read, Line 61 (Error): Don't know how to parse layer "metal8"
LEF read, Line 61 (Error): Try adding this name to the LEF techfile section
LEF read, Line 61 (Error): No layer defined for RECT.
LEF read, Line 62 (Error): Don't know how to parse layer "metal7"
LEF read, Line 62 (Error): Try adding this name to the LEF techfile section
LEF read, Line 62 (Error): No layer defined for RECT.
LEF read, Line 64 (Error): Don't know how to parse layer "via6"
LEF read, Line 64 (Error): Try adding this name to the LEF techfile section
LEF read, Line 64 (Error): No layer defined for RECT.
LEF read, Line 65 (Error): Don't know how to parse layer "metal7"
LEF read, Line 65 (Error): Try adding this name to the LEF techfile section
LEF read, Line 65 (Error): No layer defined for RECT.
LEF read, Line 68 (Warning): Cut size for magic type "(null)" (6 x 6) does not match LEF/DEF
LEF read, Line 68 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 72 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 72 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 76 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 76 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 80 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 80 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 84 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 84 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 90 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 90 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 91 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 91 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 92 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 92 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 93 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 93 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 94 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 94 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 95 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 95 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 96 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 96 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 97 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 97 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 101 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 101 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 102 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 102 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 103 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 103 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 104 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 104 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 105 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 105 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 106 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 106 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 107 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 111 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 111 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 112 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 112 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 113 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 113 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 114 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 114 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 115 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 115 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 117 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 117 (Warning): Via cut size (1 x 2).  Magic layer cut size will be used!
LEF read, Line 121 (Warning): Cut size for magic type "metal4" (4 x 4) does not match LEF/DEF
LEF read, Line 121 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 122 (Warning): Cut size for magic type "m5contact" (4 x 4) does not match LEF/DEF
LEF read, Line 122 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 123 (Warning): Cut size for magic type "m5contact" (4 x 4) does not match LEF/DEF
LEF read, Line 123 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 124 (Warning): Cut size for magic type "m5contact" (4 x 4) does not match LEF/DEF
LEF read, Line 124 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 128 (Warning): Cut size for magic type "metal5" (6 x 6) does not match LEF/DEF
LEF read, Line 128 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 129 (Warning): Cut size for magic type "m6contact" (6 x 6) does not match LEF/DEF
LEF read, Line 129 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 130 (Warning): Cut size for magic type "m6contact" (6 x 6) does not match LEF/DEF
LEF read, Line 130 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 131 (Warning): Cut size for magic type "m6contact" (6 x 6) does not match LEF/DEF
LEF read, Line 131 (Warning): Via cut size (3 x 2).  Magic layer cut size will be used!
LEF read, Line 134 (Error): Don't know how to parse layer "metal7"
LEF read, Line 134 (Error): Try adding this name to the LEF techfile section
LEF read, Line 134 (Error): No layer defined for RECT.
LEF read, Line 135 (Error): Don't know how to parse layer "via6"
LEF read, Line 135 (Error): Try adding this name to the LEF techfile section
LEF read, Line 135 (Error): No layer defined for RECT.
LEF read, Line 136 (Error): Don't know how to parse layer "via6"
LEF read, Line 136 (Error): Try adding this name to the LEF techfile section
LEF read, Line 136 (Error): No layer defined for RECT.
LEF read, Line 137 (Error): Don't know how to parse layer "via6"
LEF read, Line 137 (Error): Try adding this name to the LEF techfile section
LEF read, Line 137 (Error): No layer defined for RECT.
LEF read, Line 139 (Error): Don't know how to parse layer "metal7"
LEF read, Line 139 (Error): Try adding this name to the LEF techfile section
LEF read, Line 139 (Error): No layer defined for RECT.
LEF read, Line 140 (Error): Don't know how to parse layer "metal8"
LEF read, Line 140 (Error): Try adding this name to the LEF techfile section
LEF read, Line 140 (Error): No layer defined for RECT.
LEF read, Line 141 (Error): Don't know how to parse layer "via7"
LEF read, Line 141 (Error): Try adding this name to the LEF techfile section
LEF read, Line 141 (Error): No layer defined for RECT.
LEF read, Line 143 (Error): Don't know how to parse layer "metal8"
LEF read, Line 143 (Error): Try adding this name to the LEF techfile section
LEF read, Line 143 (Error): No layer defined for RECT.
LEF read, Line 144 (Error): Don't know how to parse layer "metal9"
LEF read, Line 144 (Error): Try adding this name to the LEF techfile section
LEF read, Line 144 (Error): No layer defined for RECT.
LEF read, Line 145 (Error): Don't know how to parse layer "via8"
LEF read, Line 145 (Error): Try adding this name to the LEF techfile section
LEF read, Line 145 (Error): No layer defined for RECT.
LEF read, Line 147 (Error): Don't know how to parse layer "metal9"
LEF read, Line 147 (Error): Try adding this name to the LEF techfile section
LEF read, Line 147 (Error): No layer defined for RECT.
LEF read, Line 148 (Error): Don't know how to parse layer "metal10"
LEF read, Line 148 (Error): Try adding this name to the LEF techfile section
LEF read, Line 148 (Error): No layer defined for RECT.
LEF read, Line 149 (Error): Don't know how to parse layer "via9"
LEF read, Line 149 (Error): Try adding this name to the LEF techfile section
LEF read, Line 149 (Error): No layer defined for RECT.
LEF read, Line 153 (Error): Don't know how to parse layer "contact"
LEF read, Line 153 (Error): Try adding this name to the LEF techfile section
LEF read, Line 153 (Error): No layer defined for RECT.
LEF read, Line 154 (Error): Don't know how to parse layer "contact"
LEF read, Line 154 (Error): Try adding this name to the LEF techfile section
LEF read, Line 154 (Error): No layer defined for RECT.
LEF read, Line 155 (Error): Don't know how to parse layer "contact"
LEF read, Line 155 (Error): Try adding this name to the LEF techfile section
LEF read, Line 155 (Error): No layer defined for RECT.
LEF read, Line 156 (Error): Don't know how to parse layer "contact"
LEF read, Line 156 (Error): Try adding this name to the LEF techfile section
LEF read, Line 156 (Error): No layer defined for RECT.
LEF read, Line 157 (Error): Don't know how to parse layer "contact"
LEF read, Line 157 (Error): Try adding this name to the LEF techfile section
LEF read, Line 157 (Error): No layer defined for RECT.
LEF read, Line 158 (Error): Don't know how to parse layer "contact"
LEF read, Line 158 (Error): Try adding this name to the LEF techfile section
LEF read, Line 158 (Error): No layer defined for RECT.
LEF read, Line 159 (Error): Don't know how to parse layer "contact"
LEF read, Line 159 (Error): Try adding this name to the LEF techfile section
LEF read, Line 159 (Error): No layer defined for RECT.
LEF read, Line 160 (Error): Don't know how to parse layer "contact"
LEF read, Line 160 (Error): Try adding this name to the LEF techfile section
LEF read, Line 160 (Error): No layer defined for RECT.
Processed 26 vias total.
Processed 1107 subcell instances total.
LEF read, Line 1275 (Error): Don't know how to parse layer "metal10"
LEF read, Line 1275 (Error): Try adding this name to the LEF techfile section
LEF read, Line 1275 (Error): No layer defined for RECT.
LEF read, Line 1278 (Error): Don't know how to parse layer "metal10"
LEF Read:  Further errors will not be reported.
Processed 45 pins total.
Processed 959 nets total.
Processed 282 special nets total.
DEF read: Processed 12303 lines.
DEF Read: encountered 346 errors total.
DEF Read: encountered 84 warnings total.
Moving label "vdd" from space to m6contact in cell aluuu.
Generating LEF output aluuu.lef for cell aluuu:
Diagnostic:  Write LEF header for cell aluuu
Diagnostic:  Writing LEF output for cell aluuu
Diagnostic:  Scale value is 0.100000
Extracting AOI22X1 into AOI22X1.ext:
Extracting AOI21X1 into AOI21X1.ext:
Extracting XNOR2X1 into XNOR2X1.ext:
Extracting NAND3X1 into NAND3X1.ext:
Extracting NOR3X1 into NOR3X1.ext:
Extracting NOR2X1 into NOR2X1.ext:
Extracting NAND2X1 into NAND2X1.ext:
Extracting INVX1 into INVX1.ext:
Extracting FILL into FILL.ext:
Extracting BUFX2 into BUFX2.ext:
Extracting XOR2X1 into XOR2X1.ext:
Extracting OR2X2 into OR2X2.ext:
Extracting AND2X2 into AND2X2.ext:
Extracting aluuu into aluuu.ext:

--------------------------------
Qflow project setup
--------------------------------

Technology set to gscl45nm from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl" from command line.
Reading LEF data from file /usr/local/share/qflow/tech/gscl45nm/gscl45nm.lef.
This action cannot be undone.
LEF read, Line 186 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 186 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 195 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 195 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 204 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 204 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 213 (Warning): Cut size for magic type "metal4" (4 x 4) does not match LEF/DEF
LEF read, Line 213 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 222 (Warning): Cut size for magic type "metal5" (6 x 6) does not match LEF/DEF
LEF read, Line 222 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 230 (Error): Don't know how to parse layer "via6"
LEF read, Line 230 (Error): Try adding this name to the LEF techfile section
LEF read, Line 231 (Error): No layer defined for RECT.
LEF read, Line 232 (Error): Don't know how to parse layer "metal7"
LEF read, Line 232 (Error): Try adding this name to the LEF techfile section
LEF read, Line 233 (Error): No layer defined for RECT.
LEF read, Line 237 (Error): Don't know how to parse layer "metal7"
LEF read, Line 237 (Error): Try adding this name to the LEF techfile section
LEF read, Line 238 (Error): No layer defined for RECT.
LEF read, Line 239 (Error): Don't know how to parse layer "via7"
LEF read, Line 239 (Error): Try adding this name to the LEF techfile section
LEF read, Line 240 (Error): No layer defined for RECT.
LEF read, Line 241 (Error): Don't know how to parse layer "metal8"
LEF read, Line 241 (Error): Try adding this name to the LEF techfile section
LEF read, Line 242 (Error): No layer defined for RECT.
LEF read, Line 246 (Error): Don't know how to parse layer "metal8"
LEF read, Line 246 (Error): Try adding this name to the LEF techfile section
LEF read, Line 247 (Error): No layer defined for RECT.
LEF read, Line 248 (Error): Don't know how to parse layer "via8"
LEF read, Line 248 (Error): Try adding this name to the LEF techfile section
LEF read, Line 249 (Error): No layer defined for RECT.
LEF read, Line 250 (Error): Don't know how to parse layer "metal9"
LEF read, Line 250 (Error): Try adding this name to the LEF techfile section
LEF read, Line 251 (Error): No layer defined for RECT.
LEF read, Line 255 (Error): Don't know how to parse layer "metal9"
LEF read, Line 255 (Error): Try adding this name to the LEF techfile section
LEF read, Line 256 (Error): No layer defined for RECT.
LEF read, Line 257 (Error): Don't know how to parse layer "via9"
LEF read, Line 257 (Error): Try adding this name to the LEF techfile section
LEF read, Line 258 (Error): No layer defined for RECT.
LEF read, Line 259 (Error): Don't know how to parse layer "metal10"
LEF read, Line 259 (Error): Try adding this name to the LEF techfile section
LEF read, Line 260 (Error): No layer defined for RECT.
LEF read, Line 267 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 267 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 276 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 276 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 285 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 285 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 294 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 294 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 303 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 303 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 314 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 314 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 324 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 324 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 334 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 334 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 344 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 344 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 354 (Warning): Cut size for magic type "(null)" (6 x 6) does not match LEF/DEF
LEF read, Line 354 (Warning): Via cut size (2 x 2).  Magic layer cut size will be used!
LEF read, Line 361 (Error): Don't know how to parse layer "metal7"
LEF read, Line 361 (Error): Try adding this name to the LEF techfile section
LEF read, Line 363 (Error): Don't know how to parse layer "via6"
LEF read, Line 363 (Error): Try adding this name to the LEF techfile section
LEF read, Line 364 (Error): No layer defined for RECT.
LEF read, Line 369 (Error): Don't know how to parse layer "metal7"
LEF read, Line 369 (Error): Try adding this name to the LEF techfile section
LEF read, Line 371 (Error): Don't know how to parse layer "metal8"
LEF read, Line 371 (Error): Try adding this name to the LEF techfile section
LEF read, Line 373 (Error): Don't know how to parse layer "via7"
LEF read, Line 373 (Error): Try adding this name to the LEF techfile section
LEF read, Line 374 (Error): No layer defined for RECT.
LEF read, Line 379 (Error): Don't know how to parse layer "metal8"
LEF read, Line 379 (Error): Try adding this name to the LEF techfile section
LEF read, Line 381 (Error): Don't know how to parse layer "metal9"
LEF read, Line 381 (Error): Try adding this name to the LEF techfile section
LEF read, Line 383 (Error): Don't know how to parse layer "via8"
LEF read, Line 383 (Error): Try adding this name to the LEF techfile section
LEF read, Line 384 (Error): No layer defined for RECT.
LEF read, Line 389 (Error): Don't know how to parse layer "metal9"
LEF read, Line 389 (Error): Try adding this name to the LEF techfile section
LEF read, Line 391 (Error): Don't know how to parse layer "metal10"
LEF read, Line 391 (Error): Try adding this name to the LEF techfile section
LEF read, Line 393 (Error): Don't know how to parse layer "via9"
LEF read, Line 393 (Error): Try adding this name to the LEF techfile section
LEF read, Line 394 (Error): No layer defined for RECT.
LEF read, Line 403 (Error): Don't know how to parse layer "contact"
LEF read, Line 403 (Error): Try adding this name to the LEF techfile section
LEF read, Line 404 (Error): No layer defined for RECT.
LEF read: Processed 2937 lines.
LEF Read: encountered 62 errors total.
LEF Read: encountered 30 warnings total.
Processing timestamp mismatches: BUFX2, OR2X2, AND2X2, XOR2X1, FILL, INVX1, NOR2X1, NOR3X1, XNOR2X1, NAND2X1, AOI22X1, NAND3X1, AOI21X1.
Errors in synthesis flow, qflow status = 1

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running yosys for verilog parsing and synthesis
yosys  -s aluuu.ys

/----------------------------------------------------------------------------\
|                                                                            |
|  yosys -- Yosys Open SYnthesis Suite                                       |
|                                                                            |
|  Copyright (C) 2012 - 2020  Claire Xenia Wolf <claire@yosyshq.com>         |
|                                                                            |
|  Permission to use, copy, modify, and/or distribute this software for any  |
|  purpose with or without fee is hereby granted, provided that the above    |
|  copyright notice and this permission notice appear in all copies.         |
|                                                                            |
|  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  |
|  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF          |
|  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR   |
|  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES    |
|  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN     |
|  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF   |
|  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.            |
|                                                                            |
\----------------------------------------------------------------------------/

Yosys 0.33 (git sha1 2584903a060)


-- Executing script file `aluuu.ys' --

1. Executing Liberty frontend: /usr/local/share/qflow/tech/osu035/osu035_stdcells.lib
Imported 39 cell types from liberty file.

2. Executing Verilog-2005 frontend: /home/kor-tac/Desktop/physical/alu/source/aluuu.v
Parsing Verilog input from `/home/kor-tac/Desktop/physical/alu/source/aluuu.v' to AST representation.
Generating RTLIL representation for module `\ha'.
Generating RTLIL representation for module `\fa1'.
Generating RTLIL representation for module `\multi_10'.
/home/kor-tac/Desktop/physical/alu/source/aluuu.v:41: Warning: Identifier `\p' is implicitly declared.
Generating RTLIL representation for module `\adder_10'.
Generating RTLIL representation for module `\sub_10'.
Generating RTLIL representation for module `\comp_10'.
Generating RTLIL representation for module `\adie'.
Generating RTLIL representation for module `\orie'.
Generating RTLIL representation for module `\arilef'.
Generating RTLIL representation for module `\aririi'.
Generating RTLIL representation for module `\aluuu'.
Successfully finished Verilog frontend.

3. Executing SYNTH pass.

3.1. Executing HIERARCHY pass (managing design hierarchy).

3.1.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10

3.1.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \aririi
Used module:     \arilef
Used module:     \orie
Used module:     \adie
Used module:     \comp_10
Used module:     \sub_10
Used module:         \fa1
Used module:             \ha
Used module:     \adder_10
Used module:     \multi_10
Removed 0 unused modules.
Mapping positional arguments of cell aluuu.aR1 (aririi).
Mapping positional arguments of cell aluuu.aL1 (arilef).
Mapping positional arguments of cell aluuu.on (orie).
Mapping positional arguments of cell aluuu.an (adie).
Mapping positional arguments of cell aluuu.c1 (comp_10).
Mapping positional arguments of cell aluuu.ss1 (sub_10).
Mapping positional arguments of cell aluuu.a1 (adder_10).
Mapping positional arguments of cell aluuu.m1 (multi_10).
Mapping positional arguments of cell sub_10.f9 (fa1).
Mapping positional arguments of cell sub_10.f8 (fa1).
Mapping positional arguments of cell sub_10.f7 (fa1).
Mapping positional arguments of cell sub_10.f6 (fa1).
Mapping positional arguments of cell sub_10.f5 (fa1).
Mapping positional arguments of cell sub_10.f4 (fa1).
Mapping positional arguments of cell sub_10.f3 (fa1).
Mapping positional arguments of cell sub_10.f2 (fa1).
Mapping positional arguments of cell sub_10.f1 (fa1).
Mapping positional arguments of cell sub_10.f0 (fa1).
Mapping positional arguments of cell adder_10.f9 (fa1).
Mapping positional arguments of cell adder_10.f8 (fa1).
Mapping positional arguments of cell adder_10.f7 (fa1).
Mapping positional arguments of cell adder_10.f6 (fa1).
Mapping positional arguments of cell adder_10.f5 (fa1).
Mapping positional arguments of cell adder_10.f4 (fa1).
Mapping positional arguments of cell adder_10.f3 (fa1).
Mapping positional arguments of cell adder_10.f2 (fa1).
Mapping positional arguments of cell adder_10.f1 (fa1).
Mapping positional arguments of cell adder_10.f0 (fa1).
Mapping positional arguments of cell multi_10.h18 (fa1).
Mapping positional arguments of cell multi_10.f74 (fa1).
Mapping positional arguments of cell multi_10.f73 (fa1).
Mapping positional arguments of cell multi_10.f72 (fa1).
Mapping positional arguments of cell multi_10.f71 (fa1).
Mapping positional arguments of cell multi_10.f70 (fa1).
Mapping positional arguments of cell multi_10.f69 (fa1).
Mapping positional arguments of cell multi_10.f68 (fa1).
Mapping positional arguments of cell multi_10.f67 (fa1).
Mapping positional arguments of cell multi_10.h17 (ha).
Mapping positional arguments of cell multi_10.h16 (fa1).
Mapping positional arguments of cell multi_10.f66 (fa1).
Mapping positional arguments of cell multi_10.f65 (fa1).
Mapping positional arguments of cell multi_10.f64 (fa1).
Mapping positional arguments of cell multi_10.f63 (fa1).
Mapping positional arguments of cell multi_10.f62 (fa1).
Mapping positional arguments of cell multi_10.f61 (fa1).
Mapping positional arguments of cell multi_10.f60 (fa1).
Mapping positional arguments of cell multi_10.f59 (fa1).
Mapping positional arguments of cell multi_10.h15 (ha).
Mapping positional arguments of cell multi_10.h14 (fa1).
Mapping positional arguments of cell multi_10.f58 (fa1).
Mapping positional arguments of cell multi_10.f57 (fa1).
Mapping positional arguments of cell multi_10.f56 (fa1).
Mapping positional arguments of cell multi_10.f53 (fa1).
Mapping positional arguments of cell multi_10.f52 (fa1).
Mapping positional arguments of cell multi_10.f51 (fa1).
Mapping positional arguments of cell multi_10.f50 (fa1).
Mapping positional arguments of cell multi_10.f49 (fa1).
Mapping positional arguments of cell multi_10.h13 (ha).
Mapping positional arguments of cell multi_10.h12 (fa1).
Mapping positional arguments of cell multi_10.f48 (fa1).
Mapping positional arguments of cell multi_10.f47 (fa1).
Mapping positional arguments of cell multi_10.f46 (fa1).
Mapping positional arguments of cell multi_10.f45 (fa1).
Mapping positional arguments of cell multi_10.f44 (fa1).
Mapping positional arguments of cell multi_10.f43 (fa1).
Mapping positional arguments of cell multi_10.f42 (fa1).
Mapping positional arguments of cell multi_10.f41 (fa1).
Mapping positional arguments of cell multi_10.h11 (ha).
Mapping positional arguments of cell multi_10.h10 (fa1).
Mapping positional arguments of cell multi_10.f40 (fa1).
Mapping positional arguments of cell multi_10.f39 (fa1).
Mapping positional arguments of cell multi_10.f38 (fa1).
Mapping positional arguments of cell multi_10.f37 (fa1).
Mapping positional arguments of cell multi_10.f36 (fa1).
Mapping positional arguments of cell multi_10.f35 (fa1).
Mapping positional arguments of cell multi_10.f34 (fa1).
Mapping positional arguments of cell multi_10.f33 (fa1).
Mapping positional arguments of cell multi_10.h9 (ha).
Mapping positional arguments of cell multi_10.h8 (fa1).
Mapping positional arguments of cell multi_10.f32 (fa1).
Mapping positional arguments of cell multi_10.f31 (fa1).
Mapping positional arguments of cell multi_10.f30 (fa1).
Mapping positional arguments of cell multi_10.f29 (fa1).
Mapping positional arguments of cell multi_10.f28 (fa1).
Mapping positional arguments of cell multi_10.f27 (fa1).
Mapping positional arguments of cell multi_10.f26 (fa1).
Mapping positional arguments of cell multi_10.f25 (fa1).
Mapping positional arguments of cell multi_10.h7 (ha).
Mapping positional arguments of cell multi_10.h6 (fa1).
Mapping positional arguments of cell multi_10.f24 (fa1).
Mapping positional arguments of cell multi_10.f23 (fa1).
Mapping positional arguments of cell multi_10.f22 (fa1).
Mapping positional arguments of cell multi_10.f21 (fa1).
Mapping positional arguments of cell multi_10.f20 (fa1).
Mapping positional arguments of cell multi_10.f19 (fa1).
Mapping positional arguments of cell multi_10.f18 (fa1).
Mapping positional arguments of cell multi_10.f17 (fa1).
Mapping positional arguments of cell multi_10.h5 (ha).
Mapping positional arguments of cell multi_10.h4 (fa1).
Mapping positional arguments of cell multi_10.f16 (fa1).
Mapping positional arguments of cell multi_10.f15 (fa1).
Mapping positional arguments of cell multi_10.f14 (fa1).
Mapping positional arguments of cell multi_10.f13 (fa1).
Mapping positional arguments of cell multi_10.f12 (fa1).
Mapping positional arguments of cell multi_10.f11 (fa1).
Mapping positional arguments of cell multi_10.f10 (fa1).
Mapping positional arguments of cell multi_10.f9 (fa1).
Mapping positional arguments of cell multi_10.h3 (ha).
Mapping positional arguments of cell multi_10.h2 (ha).
Mapping positional arguments of cell multi_10.f8 (fa1).
Mapping positional arguments of cell multi_10.f7 (fa1).
Mapping positional arguments of cell multi_10.f6 (fa1).
Mapping positional arguments of cell multi_10.f5 (fa1).
Mapping positional arguments of cell multi_10.f4 (fa1).
Mapping positional arguments of cell multi_10.f3 (fa1).
Mapping positional arguments of cell multi_10.f2 (fa1).
Mapping positional arguments of cell multi_10.f1 (fa1).
Mapping positional arguments of cell multi_10.h1 (ha).
Mapping positional arguments of cell fa1.h2 (ha).
Mapping positional arguments of cell fa1.h1 (ha).
Warning: Resizing cell port aluuu.a1.sum from 10 bits to 11 bits.

3.2. Executing PROC pass (convert processes to netlists).

3.2.1. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Cleaned up 0 empty switches.

3.2.2. Executing PROC_RMDEAD pass (remove dead branches from decision trees).
Removed 1 dead cases from process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Marked 1 switch rules as full_case in process $proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366 in module aluuu.
Removed a total of 1 dead cases.

3.2.3. Executing PROC_PRUNE pass (remove redundant assignments in processes).
Removed 0 redundant assignments.
Promoted 1 assignment to connection.

3.2.4. Executing PROC_INIT pass (extract init attributes).

3.2.5. Executing PROC_ARST pass (detect async resets in processes).

3.2.6. Executing PROC_ROM pass (convert switches to ROMs).
Converted 0 switches.
<suppressed ~1 debug messages>

3.2.7. Executing PROC_MUX pass (convert decision trees to multiplexers).
Creating decoders for process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
1/1: $1\y[19:0]

3.2.8. Executing PROC_DLATCH pass (convert process syncs to latches).
No latch inferred for signal `\aluuu.\y' from process `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.

3.2.9. Executing PROC_DFF pass (convert process syncs to FFs).

3.2.10. Executing PROC_MEMWR pass (convert process memory writes to cells).

3.2.11. Executing PROC_CLEAN pass (remove empty switches from decision trees).
Found and cleaned up 1 empty switch in `\aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Removing empty process `aluuu.$proc$/home/kor-tac/Desktop/physical/alu/source/aluuu.v:265$366'.
Cleaned up 1 empty switch.

3.2.12. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module aririi.
<suppressed ~1 debug messages>
Optimizing module arilef.
<suppressed ~1 debug messages>
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
<suppressed ~1 debug messages>
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.3. Executing OPT_EXPR pass (perform const folding).
Optimizing module aluuu.
Optimizing module aririi.
Optimizing module arilef.
Optimizing module orie.
Optimizing module adie.
Optimizing module comp_10.
Optimizing module sub_10.
Optimizing module adder_10.
Optimizing module multi_10.
Optimizing module fa1.
Optimizing module ha.

3.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \sub_10..
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Removed 0 unused cells and 16 unused wires.
<suppressed ~10 debug messages>

3.5. Executing CHECK pass (checking for obvious problems).
Checking module adder_10...
Checking module adie...
Checking module aluuu...
Checking module arilef...
Checking module aririi...
Checking module comp_10...
Checking module fa1...
Checking module ha...
Checking module multi_10...
Checking module orie...
Checking module sub_10...
Found and reported 0 problems.

3.6. Executing OPT pass (performing simple optimizations).

3.6.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
<suppressed ~486 debug messages>
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 162 cells.

3.6.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.6. Executing OPT_DFF pass (perform DFF optimizations).

3.6.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 162 unused wires.
<suppressed ~1 debug messages>

3.6.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.9. Rerunning OPT passes. (Maybe there is more to do..)

3.6.10. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.6.11. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.6.12. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.6.13. Executing OPT_DFF pass (perform DFF optimizations).

3.6.14. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.6.15. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.6.16. Finished OPT passes. (There is nothing left to do.)

3.7. Executing FSM pass (extract and optimize FSM).

3.7.1. Executing FSM_DETECT pass (finding FSMs in design).

3.7.2. Executing FSM_EXTRACT pass (extracting FSM from design).

3.7.3. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.7.5. Executing FSM_OPT pass (simple optimizations of FSMs).

3.7.6. Executing FSM_RECODE pass (re-assigning FSM state encoding).

3.7.7. Executing FSM_INFO pass (dumping all available information on FSM cells).

3.7.8. Executing FSM_MAP pass (mapping FSMs to basic logic).

3.8. Executing OPT pass (performing simple optimizations).

3.8.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.8.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.8.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.8.6. Executing OPT_DFF pass (perform DFF optimizations).

3.8.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.8.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.8.9. Finished OPT passes. (There is nothing left to do.)

3.9. Executing WREDUCE pass (reducing word size of cells).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$373_CMP0 ($eq).
Removed top 1 bits (of 3) from port B of cell aluuu.$procmux$374_CMP0 ($eq).
Removed top 2 bits (of 3) from port B of cell aluuu.$procmux$375_CMP0 ($eq).

3.10. Executing PEEPOPT pass (run peephole optimizers).

3.11. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.12. Executing ALUMACC pass (create $alu and $macc cells).
Extracting $alu and $macc cells in module adder_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module adie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aluuu:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module arilef:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module aririi:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module comp_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module fa1:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module ha:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module multi_10:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module orie:
created 0 $alu and 0 $macc cells.
Extracting $alu and $macc cells in module sub_10:
created 0 $alu and 0 $macc cells.

3.13. Executing SHARE pass (SAT-based resource sharing).

3.14. Executing OPT pass (performing simple optimizations).

3.14.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.14.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.14.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.14.6. Executing OPT_DFF pass (perform DFF optimizations).

3.14.7. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.14.8. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.14.9. Finished OPT passes. (There is nothing left to do.)

3.15. Executing MEMORY pass.

3.15.1. Executing OPT_MEM pass (optimize memories).
Performed a total of 0 transformations.

3.15.2. Executing OPT_MEM_PRIORITY pass (removing unnecessary memory write priority relations).
Performed a total of 0 transformations.

3.15.3. Executing OPT_MEM_FEEDBACK pass (finding memory read-to-write feedback paths).

3.15.4. Executing MEMORY_BMUX2ROM pass (converting muxes to ROMs).

3.15.5. Executing MEMORY_DFF pass (merging $dff cells to $memrd).

3.15.6. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.7. Executing MEMORY_SHARE pass (consolidating $memrd/$memwr cells).

3.15.8. Executing OPT_MEM_WIDEN pass (optimize memories where all ports are wide).
Performed a total of 0 transformations.

3.15.9. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.15.10. Executing MEMORY_COLLECT pass (generating $mem cells).

3.16. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.17. Executing OPT pass (performing simple optimizations).

3.17.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~1 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.17.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.17.3. Executing OPT_DFF pass (perform DFF optimizations).

3.17.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 1 unused cells and 1 unused wires.
<suppressed ~2 debug messages>

3.17.5. Finished fast OPT passes.

3.18. Executing MEMORY_MAP pass (converting memories to logic and flip-flops).

3.19. Executing OPT pass (performing simple optimizations).

3.19.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..
Creating internal representation of mux trees.
Evaluating internal representation of mux trees.
Analyzing evaluation results.
Running muxtree optimizer on module \arilef..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aririi..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \comp_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \fa1..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \ha..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \multi_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \orie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \sub_10..
Creating internal representation of mux trees.
No muxes found in this module.
Removed 0 multiplexer ports.
<suppressed ~1 debug messages>

3.19.4. Executing OPT_REDUCE pass (consolidate $*mux and $reduce_* inputs).
Optimizing cells in module \adder_10.
Optimizing cells in module \adie.
Optimizing cells in module \aluuu.
Optimizing cells in module \arilef.
Optimizing cells in module \aririi.
Optimizing cells in module \comp_10.
Optimizing cells in module \fa1.
Optimizing cells in module \ha.
Optimizing cells in module \multi_10.
Optimizing cells in module \orie.
Optimizing cells in module \sub_10.
Performed a total of 0 changes.

3.19.5. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.19.6. Executing OPT_SHARE pass.

3.19.7. Executing OPT_DFF pass (perform DFF optimizations).

3.19.8. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..

3.19.9. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.19.10. Finished OPT passes. (There is nothing left to do.)

3.20. Executing TECHMAP pass (map to technology primitives).

3.20.1. Executing Verilog-2005 frontend: /usr/bin/../share/yosys/techmap.v
Parsing Verilog input from `/usr/bin/../share/yosys/techmap.v' to AST representation.
Generating RTLIL representation for module `\_90_simplemap_bool_ops'.
Generating RTLIL representation for module `\_90_simplemap_reduce_ops'.
Generating RTLIL representation for module `\_90_simplemap_logic_ops'.
Generating RTLIL representation for module `\_90_simplemap_compare_ops'.
Generating RTLIL representation for module `\_90_simplemap_various'.
Generating RTLIL representation for module `\_90_simplemap_registers'.
Generating RTLIL representation for module `\_90_shift_ops_shr_shl_sshl_sshr'.
Generating RTLIL representation for module `\_90_shift_shiftx'.
Generating RTLIL representation for module `\_90_fa'.
Generating RTLIL representation for module `\_90_lcu'.
Generating RTLIL representation for module `\_90_alu'.
Generating RTLIL representation for module `\_90_macc'.
Generating RTLIL representation for module `\_90_alumacc'.
Generating RTLIL representation for module `\$__div_mod_u'.
Generating RTLIL representation for module `\$__div_mod_trunc'.
Generating RTLIL representation for module `\_90_div'.
Generating RTLIL representation for module `\_90_mod'.
Generating RTLIL representation for module `\$__div_mod_floor'.
Generating RTLIL representation for module `\_90_divfloor'.
Generating RTLIL representation for module `\_90_modfloor'.
Generating RTLIL representation for module `\_90_pow'.
Generating RTLIL representation for module `\_90_pmux'.
Generating RTLIL representation for module `\_90_demux'.
Generating RTLIL representation for module `\_90_lut'.
Successfully finished Verilog frontend.

3.20.2. Continuing TECHMAP pass.
Using extmapper simplemap for cells of type $not.
Using extmapper simplemap for cells of type $or.
Using extmapper simplemap for cells of type $and.
Using extmapper simplemap for cells of type $xor.
Using extmapper simplemap for cells of type $xnor.
Using extmapper simplemap for cells of type $eq.
Using template $paramod$43fa60c46e83442767389184ae02572e3838275f\_90_pmux for cells of type $pmux.
Using extmapper simplemap for cells of type $reduce_or.
Using extmapper simplemap for cells of type $mux.
No more expansions possible.
<suppressed ~324 debug messages>

3.21. Executing OPT pass (performing simple optimizations).

3.21.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
<suppressed ~153 debug messages>
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.21.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
<suppressed ~36 debug messages>
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 12 cells.

3.21.3. Executing OPT_DFF pass (perform DFF optimizations).

3.21.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 125 unused wires.
<suppressed ~1 debug messages>

3.21.5. Finished fast OPT passes.

3.22. Executing ABC pass (technology mapping using ABC).

3.22.1. Extracting gate netlist of module `\adder_10' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.2. Extracting gate netlist of module `\adie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.2.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.2.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.3. Extracting gate netlist of module `\aluuu' to `<abc-temp-dir>/input.blif'..
Extracted 175 gates and 263 wires to a netlist network with 87 inputs and 20 outputs.

3.22.3.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.3.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:              NAND cells:        3
ABC RESULTS:                OR cells:       61
ABC RESULTS:               MUX cells:       10
ABC RESULTS:             ORNOT cells:       14
ABC RESULTS:            ANDNOT cells:       77
ABC RESULTS:        internal signals:      156
ABC RESULTS:           input signals:       87
ABC RESULTS:          output signals:       20
Removing temp directory.

3.22.4. Extracting gate netlist of module `\arilef' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.5. Extracting gate netlist of module `\aririi' to `<abc-temp-dir>/input.blif'..
Extracted 0 gates and 0 wires to a netlist network with 0 inputs and 0 outputs.
Don't call ABC as there is nothing to map.
Removing temp directory.

3.22.6. Extracting gate netlist of module `\comp_10' to `<abc-temp-dir>/input.blif'..
Extracted 95 gates and 115 wires to a netlist network with 20 inputs and 3 outputs.

3.22.6.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.6.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:       10
ABC RESULTS:               NOR cells:        1
ABC RESULTS:               NOT cells:       18
ABC RESULTS:            ANDNOT cells:       20
ABC RESULTS:                OR cells:       44
ABC RESULTS:        internal signals:       92
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:        3
Removing temp directory.

3.22.7. Extracting gate netlist of module `\fa1' to `<abc-temp-dir>/input.blif'..
Extracted 1 gates and 3 wires to a netlist network with 2 inputs and 1 outputs.

3.22.7.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.7.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        1
Removing temp directory.

3.22.8. Extracting gate netlist of module `\ha' to `<abc-temp-dir>/input.blif'..
Extracted 2 gates and 4 wires to a netlist network with 2 inputs and 2 outputs.

3.22.8.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.8.2. Re-integrating ABC results.
ABC RESULTS:               XOR cells:        1
ABC RESULTS:               AND cells:        1
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:        2
ABC RESULTS:          output signals:        2
Removing temp directory.

3.22.9. Extracting gate netlist of module `\multi_10' to `<abc-temp-dir>/input.blif'..
Extracted 100 gates and 120 wires to a netlist network with 20 inputs and 100 outputs.

3.22.9.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.9.2. Re-integrating ABC results.
ABC RESULTS:               AND cells:      100
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:      100
Removing temp directory.

3.22.10. Extracting gate netlist of module `\orie' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 30 wires to a netlist network with 20 inputs and 10 outputs.

3.22.10.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.10.2. Re-integrating ABC results.
ABC RESULTS:                OR cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       20
ABC RESULTS:          output signals:       10
Removing temp directory.

3.22.11. Extracting gate netlist of module `\sub_10' to `<abc-temp-dir>/input.blif'..
Extracted 10 gates and 20 wires to a netlist network with 10 inputs and 10 outputs.

3.22.11.1. Executing ABC.
Running ABC command: "<yosys-exe-dir>/yosys-abc" -s -f <abc-temp-dir>/abc.script 2>&1
ABC: ABC command line: "source <abc-temp-dir>/abc.script".
ABC:
ABC: + read_blif <abc-temp-dir>/input.blif
ABC: + read_library <abc-temp-dir>/stdcells.genlib
ABC: Entered genlib library with 13 gates from file "<abc-temp-dir>/stdcells.genlib".
ABC: + strash
ABC: + dretime
ABC: + map
ABC: + write_blif <abc-temp-dir>/output.blif

3.22.11.2. Re-integrating ABC results.
ABC RESULTS:               NOT cells:       10
ABC RESULTS:        internal signals:        0
ABC RESULTS:           input signals:       10
ABC RESULTS:          output signals:       10
Removing temp directory.

3.23. Executing OPT pass (performing simple optimizations).

3.23.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

3.23.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

3.23.3. Executing OPT_DFF pass (perform DFF optimizations).

3.23.4. Executing OPT_CLEAN pass (remove unused cells and wires).
Finding unused cells or wires in module \adder_10..
Finding unused cells or wires in module \adie..
Finding unused cells or wires in module \aluuu..
Finding unused cells or wires in module \arilef..
Finding unused cells or wires in module \aririi..
Finding unused cells or wires in module \comp_10..
Finding unused cells or wires in module \fa1..
Finding unused cells or wires in module \ha..
Finding unused cells or wires in module \multi_10..
Finding unused cells or wires in module \orie..
Finding unused cells or wires in module \sub_10..
Removed 0 unused cells and 469 unused wires.
<suppressed ~8 debug messages>

3.23.5. Finished fast OPT passes.

3.24. Executing HIERARCHY pass (managing design hierarchy).

3.24.1. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10

3.24.2. Analyzing design hierarchy..
Top module:  \aluuu
Used module:     \adder_10
Used module:         \fa1
Used module:             \ha
Used module:     \arilef
Used module:     \aririi
Used module:     \adie
Used module:     \comp_10
Used module:     \multi_10
Used module:     \orie
Used module:     \sub_10
Removed 0 unused modules.

3.25. Printing statistics.

=== adder_10 ===

Number of wires:                  4
Number of wire bits:             40
Number of public wires:           4
Number of public wire bits:      40
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
fa1                            10

=== adie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_AND_                         10

=== aluuu ===

Number of wires:                160
Number of wire bits:            275
Number of public wires:          12
Number of public wire bits:     127
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                175
$_ANDNOT_                      77
$_AND_                          1
$_MUX_                         10
$_NAND_                         3
$_NOT_                          1
$_ORNOT_                       14
$_OR_                          61
adder_10                        1
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
orie                            1
sub_10                          1

=== arilef ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== aririi ===

Number of wires:                  2
Number of wire bits:             20
Number of public wires:           2
Number of public wire bits:      20
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  0

=== comp_10 ===

Number of wires:                 93
Number of wire bits:            113
Number of public wires:           3
Number of public wire bits:      23
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 93
$_ANDNOT_                      20
$_NOR_                          1
$_NOT_                         18
$_OR_                          44
$_XOR_                         10

=== fa1 ===

Number of wires:                  8
Number of wire bits:              8
Number of public wires:           8
Number of public wire bits:       8
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  3
$_OR_                           1
ha                              2

=== ha ===

Number of wires:                  4
Number of wire bits:              4
Number of public wires:           4
Number of public wire bits:       4
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                  2
$_AND_                          1
$_XOR_                          1

=== multi_10 ===

Number of wires:                264
Number of wire bits:            301
Number of public wires:         165
Number of public wire bits:     202
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                190
$_AND_                        100
fa1                            80
ha                             10

=== orie ===

Number of wires:                  3
Number of wire bits:             30
Number of public wires:           3
Number of public wire bits:      30
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 10
$_OR_                          10

=== sub_10 ===

Number of wires:                  5
Number of wire bits:             51
Number of public wires:           5
Number of public wire bits:      51
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                 20
$_NOT_                         10
fa1                            10

=== design hierarchy ===

aluuu                             1
adder_10                        1
fa1                          10
ha                          2
adie                            1
arilef                          1
aririi                          1
comp_10                         1
multi_10                        1
fa1                          80
ha                          2
ha                           10
orie                            1
sub_10                          1
fa1                          10
ha                          2

Number of wires:               2176
Number of wire bits:           2520
Number of public wires:        1839
Number of public wire bits:    2183
Number of memories:               0
Number of memory bits:            0
Number of processes:              0
Number of cells:                910
$_ANDNOT_                      97
/usr/local/share/qflow/scripts/spi2xspice.py:32: SyntaxWarning: invalid escape sequence '\*'
$_AND_                        321
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
$_MUX_                         10
/usr/local/share/qflow/scripts/spi2xspice.py:33: SyntaxWarning: invalid escape sequence '\*'
$_NAND_                         3
subrex  = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
$_NOR_                          1
/usr/local/share/qflow/scripts/spi2xspice.py:34: SyntaxWarning: invalid escape sequence '\*'
$_NOT_                         29
endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
$_ORNOT_                       14
/usr/local/share/qflow/scripts/spi2xspice.py:35: SyntaxWarning: invalid escape sequence '\*'
$_OR_                         215
comrex  = re.compile('^[\*]+.*$', re.IGNORECASE)
$_XOR_                        220
/usr/local/share/qflow/scripts/spi2xspice.py:96: SyntaxWarning: invalid escape sequence '\)'

imprex = re.compile('([10\)])[ \t]+([10\(])')
3.26. Executing CHECK pass (checking for obvious problems).
/usr/local/share/qflow/scripts/spi2xspice.py:97: SyntaxWarning: invalid escape sequence '\)'
Checking module adder_10...
primerex = re.compile('([10\)])[ \t]*\'')
Checking module adie...
/usr/local/share/qflow/scripts/spi2xspice.py:143: SyntaxWarning: invalid escape sequence '\g'
Checking module aluuu...
psubs = imprex.sub('\g<1>&\g<2>', psubs)
Checking module arilef...
/usr/local/share/qflow/scripts/spi2xspice.py:208: SyntaxWarning: invalid escape sequence '\*'
Checking module aririi...
increx = re.compile('^[^\*]*[ \t]*.include[ \t]+([^ \t]+).*$', re.IGNORECASE)
Checking module comp_10...
/usr/local/share/qflow/scripts/spi2xspice.py:209: SyntaxWarning: invalid escape sequence '\*'
Checking module fa1...
subrex = re.compile('^[^\*]*[ \t]*.subckt[ \t]+([^ \t]+)(.*)$', re.IGNORECASE)
Checking module ha...
/usr/local/share/qflow/scripts/spi2xspice.py:211: SyntaxWarning: invalid escape sequence '\*'
Checking module multi_10...
comrex = re.compile('^[\*]+.*$', re.IGNORECASE)
Checking module orie...
/usr/local/share/qflow/scripts/spi2xspice.py:212: SyntaxWarning: invalid escape sequence '\*'
Checking module sub_10...
specrex = re.compile('^[\*]+This file may contain array delimiters', re.IGNORECASE)
Found and reported 0 problems.
/usr/local/share/qflow/scripts/spi2xspice.py:213: SyntaxWarning: invalid escape sequence '\*'

endsrex = re.compile('^[^\*]*[ \t]*.ends.*$', re.IGNORECASE)
4. Executing DFFLIBMAP pass (mapping DFF cells to sequential cells from liberty file).
/usr/local/share/qflow/scripts/spi2xspice.py:214: SyntaxWarning: invalid escape sequence '\*'
cell DFFNEGX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_N_.
endrex = re.compile('^[^\*]*[ \t]*.end.*$', re.IGNORECASE)
cell DFFPOSX1 (noninv, pins=3, area=384.00) is a direct match for cell type $_DFF_P_.
/usr/local/share/qflow/scripts/spi2xspice.py:664: SyntaxWarning: invalid escape sequence '\('
cell DFFSR (noninv, pins=5, area=704.00) is a direct match for cell type $_DFFSR_PNN_.
outparenrex = re.compile('^[ \t]*\([ \t]*(.+)[ \t]*\)[ \t]*$')
final dff cell mappings:
/usr/local/share/qflow/scripts/spi2xspice.py:665: SyntaxWarning: invalid escape sequence '\('
\DFFNEGX1 _DFF_N_ (.CLK( C), .D( D), .Q( Q));
parenrex = re.compile('\([ \t]*([^ \t\)|&~^]+)[ \t]*\)')
\DFFPOSX1 _DFF_P_ (.CLK( C), .D( D), .Q( Q));
/usr/local/share/qflow/scripts/spi2xspice.py:668: SyntaxWarning: invalid escape sequence '\g'
unmapped dff cell: $_DFF_NN0_
pstring = outparenrex.sub('\g<1>', pstring)
unmapped dff cell: $_DFF_NN1_
/usr/local/share/qflow/scripts/spi2xspice.py:669: SyntaxWarning: invalid escape sequence '\g'
unmapped dff cell: $_DFF_NP0_
pstring = parenrex.sub('\g<1>', pstring)
unmapped dff cell: $_DFF_NP1_
/usr/local/share/qflow/scripts/spi2xspice.py:670: SyntaxWarning: invalid escape sequence '\g'
unmapped dff cell: $_DFF_PN0_
pstring = primerex.sub('~\g<1>', pstring)
unmapped dff cell: $_DFF_PN1_
/usr/local/share/qflow/scripts/spi2xspice.py:678: SyntaxWarning: invalid escape sequence '\('
unmapped dff cell: $_DFF_PP0_
cellrex  = re.compile('[ \t]*cell[ \t]*\(([^)]+)\)')
unmapped dff cell: $_DFF_PP1_
/usr/local/share/qflow/scripts/spi2xspice.py:679: SyntaxWarning: invalid escape sequence '\('
unmapped dff cell: $_DFFSR_NNN_
pinrex   = re.compile('[ \t]*pin[ \t]*\(([^)]+)\)')
unmapped dff cell: $_DFFSR_NNP_
/usr/local/share/qflow/scripts/spi2xspice.py:680: SyntaxWarning: invalid escape sequence '\('
unmapped dff cell: $_DFFSR_NPN_
busrex   = re.compile('[ \t]*bus[ \t]*\(([^)]+)\)')
unmapped dff cell: $_DFFSR_NPP_
/usr/local/share/qflow/scripts/spi2xspice.py:681: SyntaxWarning: invalid escape sequence '\('
\DFFSR _DFFSR_PNN_ (.CLK( C), .D( D), .Q( Q), .R( R), .S( S));
lat1rex  = re.compile('[ \t]*latch[ \t]*\(([^)]+)\)')
unmapped dff cell: $_DFFSR_PNP_
/usr/local/share/qflow/scripts/spi2xspice.py:682: SyntaxWarning: invalid escape sequence '\('
unmapped dff cell: $_DFFSR_PPN_
lat2rex  = re.compile('[ \t]*latch[ \t]*\(([^, \t]+)[ \t]*,[ \t]*([^),]+)\)')
unmapped dff cell: $_DFFSR_PPP_
/usr/local/share/qflow/scripts/spi2xspice.py:683: SyntaxWarning: invalid escape sequence '\('

ff1rex   = re.compile('[ \t]*ff[ \t]*\(([^)]+)\)')
4.1. Executing DFFLEGALIZE pass (convert FFs to types supported by the target).
/usr/local/share/qflow/scripts/spi2xspice.py:684: SyntaxWarning: invalid escape sequence '\('
Mapping DFF cells in module `\adder_10':
ff2rex   = re.compile('[ \t]*ff[ \t]*\(([^, \t]+)[ \t]*,[ \t]*([^),]+)\)')
Mapping DFF cells in module `\adie':
Mapping DFF cells in module `\aluuu':
Mapping DFF cells in module `\arilef':
Mapping DFF cells in module `\aririi':
Mapping DFF cells in module `\comp_10':
Mapping DFF cells in module `\fa1':
Mapping DFF cells in module `\ha':
Mapping DFF cells in module `\multi_10':
Mapping DFF cells in module `\orie':
Mapping DFF cells in module `\sub_10':

5. Executing OPT pass (performing simple optimizations).

5.1. Executing OPT_EXPR pass (perform const folding).
Optimizing module adder_10.
Optimizing module adie.
Optimizing module aluuu.
Optimizing module arilef.
Optimizing module aririi.
Optimizing module comp_10.
Optimizing module fa1.
Optimizing module ha.
Optimizing module multi_10.
Optimizing module orie.
Optimizing module sub_10.

5.2. Executing OPT_MERGE pass (detect identical cells).
Finding identical cells in module `\adder_10'.
Finding identical cells in module `\adie'.
Finding identical cells in module `\aluuu'.
Finding identical cells in module `\arilef'.
Finding identical cells in module `\aririi'.
Finding identical cells in module `\comp_10'.
Finding identical cells in module `\fa1'.
Finding identical cells in module `\ha'.
Finding identical cells in module `\multi_10'.
Finding identical cells in module `\orie'.
Finding identical cells in module `\sub_10'.
Removed a total of 0 cells.

5.3. Executing OPT_MUXTREE pass (detect dead branches in mux trees).
Running muxtree optimizer on module \adder_10..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \adie..
Creating internal representation of mux trees.
No muxes found in this module.
Running muxtree optimizer on module \aluuu..


LEF Read, Line 135: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 136: NOTE:  Old format VIARULE ignored.
Qflow project setup
LEF Read, Line 140: NOTE:  Old format VIARULE ignored.
--------------------------------
LEF Read, Line 141: NOTE:  Old format VIARULE ignored.

LEF Read, Line 151: NOTE:  Old format VIARULE ignored.
Technology set to osu035 from existing qflow_vars.sh file
LEF Read, Line 152: NOTE:  Old format VIARULE ignored.
Regenerating files for existing project aluuu
LEF Read, Line 156: NOTE:  Old format VIARULE ignored.
Qrouter detail maze router version 1.4.71.T
LEF Read, Line 157: NOTE:  Old format VIARULE ignored.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
LEF Read, Line 167: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site corner (ignored)
LEF Read, Line 168: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site IO (ignored)
LEF Read, Line 172: NOTE:  Old format VIARULE ignored.
LEF file:  Defines site core (ignored)
LEF Read, Line 173: NOTE:  Old format VIARULE ignored.
LEF read: Processed 3179 lines.
LEF Read: encountered 0 errors and 12 warnings total.
Vertical route layer at non-minimum pitch 3.2.  Using smaller pitch 1.6, will route on 1-of-2 tracks for layer metal4.
Running blif2cel to generate input files for graywolf
blif2cel.tcl --blif /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif  --lef  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef --cel /home/kor-tac/Desktop/physical/alu/layout/aluuu.cel
No aluuu.cel1 file found for project. . . no partial blockages to apply to layout.
Preparing pin placement hints from aluuu.cel2
Running GrayWolf placement
graywolf  aluuu
Running getfillcell to determine cell to use for fill.
getfillcell.tcl aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Using cell FILL for fill
Running place2def to translate graywolf output to DEF format.
place2def.tcl aluuu FILL
Running addspacers to generate power stripes and align cell right edge
addspacers.tcl  -stripe 5.0 150.0 PG aluuu  /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef FILL
Running arrangepins to adjust pin positions for optimal routing.
arrangepins.tcl  aluuu
Reading info file aluuu.info. . .
Reading DEF file aluuu.def. . .
Recalculating pin positions
Writing DEF file aluuu_mod.def. . .
Done with arrangepins.tcl
blifanno.tcl /home/kor-tac/Desktop/physical/alu/synthesis/aluuu.blif aluuu.def /home/kor-tac/Desktop/physical/alu/synthesis/aluuu_anno.blif

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running qrouter 1.4.71.T
qrouter -noc  -s aluuu.cfg

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  migrate_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "migrate_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
Reading DEF data from file aluuu.def.
This action cannot be undone.
LEF read, Line 20 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 20 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 21 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 21 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 22 (Warning): Cut size for magic type "m2contact" (4 x 4) does not match LEF/DEF
LEF read, Line 22 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 26 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 26 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 27 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 27 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 28 (Warning): Cut size for magic type "m3contact" (4 x 4) does not match LEF/DEF
LEF read, Line 28 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 32 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 32 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 33 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 33 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 34 (Warning): Cut size for magic type "m4contact" (4 x 4) does not match LEF/DEF
LEF read, Line 34 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
Processed 3 vias total.
Processed 1231 subcell instances total.
Processed 45 pins total.
Processed 1125 nets total.
Processed 63 special nets total.
DEF read: Processed 13465 lines.
DEF Read: encountered 18 warnings total.
Generating LEF output aluuu.lef for cell aluuu:
Diagnostic:  Write LEF header for cell aluuu
Diagnostic:  Writing LEF output for cell aluuu
Diagnostic:  Scale value is 0.100000
Extracting NOR3X1 into NOR3X1.ext:
Extracting OAI22X1 into OAI22X1.ext:
Extracting AOI22X1 into AOI22X1.ext:
Extracting NAND3X1 into NAND3X1.ext:
Extracting XNOR2X1 into XNOR2X1.ext:
Extracting NAND2X1 into NAND2X1.ext:
Extracting OAI21X1 into OAI21X1.ext:
Extracting AOI21X1 into AOI21X1.ext:
Extracting INVX1 into INVX1.ext:
Extracting BUFX2 into BUFX2.ext:
Extracting FILL into FILL.ext:
Extracting OR2X2 into OR2X2.ext:
Extracting AND2X2 into AND2X2.ext:
Extracting NOR2X1 into NOR2X1.ext:
Extracting aluuu into aluuu.ext:

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/run_drc_aluuu.tcl" from command line.
Reading LEF data from file /usr/local/share/qflow/tech/osu035/osu035_stdcells.lef.
This action cannot be undone.
LEF read, Line 16 (Message): Unknown keyword "OBS" in LEF file; ignoring.
LEF read, Line 17 (Message): Unknown keyword "PIN" in LEF file; ignoring.
LEF read, Line 107 (Warning): Cut size for magic type "metal1" (4 x 4) does not match LEF/DEF
LEF read, Line 107 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 116 (Warning): Cut size for magic type "metal2" (4 x 4) does not match LEF/DEF
LEF read, Line 116 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 125 (Warning): Cut size for magic type "metal3" (4 x 4) does not match LEF/DEF
LEF read, Line 125 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 143 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 143 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 159 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 159 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read, Line 175 (Warning): Cut size for magic type "(null)" (4 x 4) does not match LEF/DEF
LEF read, Line 175 (Warning): Via cut size (8 x 8).  Magic layer cut size will be used!
LEF read: Processed 3179 lines.
LEF Read: encountered 12 warnings total.
aluuu: 10000 rects
aluuu: 20000 rects
aluuu: 30000 rects

--------------------------------
Qflow project setup
--------------------------------

Technology set to osu035 from existing qflow_vars.sh file
Regenerating files for existing project aluuu
Running magic 8.3.105
magic -dnull -noconsole  /home/kor-tac/Desktop/physical/alu/layout/generate_gds_aluuu.tcl

Magic 8.3 revision 105 - Compiled on Mon, 06 Dec 2021 22:32:27 +0200.
Starting magic under Tcl interpreter
Using the terminal as the console.
Using NULL graphics device.
Processing system .magicrc file
"/usr/local/share/qflow/tech/osu018/osu018.tech" isn't a valid tech option.  Type ":tech help" for help.
Input style lambda=0.10(p): scaleFactor=10, multiplier=1
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Contact size value ignored (using GDS generation rules).
Loading "/home/kor-tac/Desktop/physical/alu/layout/generate_gds_aluuu.tcl" from command line.
Root cell box:
width x height  (   llx,  lly  ), (   urx,  ury  )

microns:    0.00 x 0.00    (  0.00,  0.00 ), (  0.00,  0.00 )
lambda:        0 x 0       (     0,  0    ), (     0,  0    )
Warning: Calma reading is not undoable!  I hope that's OK.
Library written using GDS-II Release 3.0
Library name: iit_stdcells
Reading "FILL".
Moving label "vdd" from space to metal1 in cell FILL.
Moving label "gnd" from space to metal1 in cell FILL.
Reading "AND2X1".
Moving label "Y" from space to metal1 in cell AND2X1.
Moving label "B" from space to metal1 in cell AND2X1.
Moving label "vdd" from space to metal1 in cell AND2X1.
Moving label "gnd" from space to metal1 in cell AND2X1.
Moving label "A" from space to metal1 in cell AND2X1.
Reading "AND2X2".
Moving label "vdd" from space to metal1 in cell AND2X2.
Moving label "gnd" from space to metal1 in cell AND2X2.
Moving label "A" from space to metal1 in cell AND2X2.
Moving label "B" from space to metal1 in cell AND2X2.
Moving label "Y" from space to metal1 in cell AND2X2.
Reading "AOI21X1".
Moving label "gnd" from space to metal1 in cell AOI21X1.
Moving label "vdd" from space to metal1 in cell AOI21X1.
Moving label "A" from space to metal1 in cell AOI21X1.
Moving label "B" from space to metal1 in cell AOI21X1.
Moving label "Y" from space to metal1 in cell AOI21X1.
Moving label "C" from space to metal1 in cell AOI21X1.
Reading "AOI22X1".
Moving label "gnd" from space to metal1 in cell AOI22X1.
Moving label "vdd" from space to metal1 in cell AOI22X1.
Moving label "C" from space to metal1 in cell AOI22X1.
Moving label "D" from space to metal1 in cell AOI22X1.
Moving label "Y" from space to metal1 in cell AOI22X1.
Moving label "A" from space to metal1 in cell AOI22X1.
Moving label "B" from space to metal1 in cell AOI22X1.
Reading "BUFX2".
Moving label "vdd" from space to metal1 in cell BUFX2.
Moving label "gnd" from space to metal1 in cell BUFX2.
Moving label "A" from space to metal1 in cell BUFX2.
Moving label "Y" from space to metal1 in cell BUFX2.
Reading "BUFX4".
Moving label "vdd" from space to metal1 in cell BUFX4.
Moving label "gnd" from space to metal1 in cell BUFX4.
Moving label "A" from space to metal1 in cell BUFX4.
Moving label "Y" from space to metal1 in cell BUFX4.
Reading "DFFNEGX1".
Moving label "CLK" from space to metal1 in cell DFFNEGX1.
Moving label "vdd" from space to metal1 in cell DFFNEGX1.
Moving label "D" from space to metal1 in cell DFFNEGX1.
Moving label "gnd" from space to metal1 in cell DFFNEGX1.
Moving label "Q" from space to metal1 in cell DFFNEGX1.
Reading "NOR3X1".
Moving label "vdd" from space to metal1 in cell NOR3X1.
Moving label "gnd" from space to metal1 in cell NOR3X1.
Moving label "B" from space to metal1 in cell NOR3X1.
Moving label "C" from space to metal1 in cell NOR3X1.
Moving label "A" from space to metal1 in cell NOR3X1.
Moving label "Y" from space to metal1 in cell NOR3X1.
Reading "DFFPOSX1".
Moving label "vdd" from space to metal1 in cell DFFPOSX1.
Moving label "D" from space to metal1 in cell DFFPOSX1.
Moving label "gnd" from space to metal1 in cell DFFPOSX1.
Moving label "Q" from space to metal1 in cell DFFPOSX1.
Moving label "CLK" from space to metal1 in cell DFFPOSX1.
Reading "FAX1".
Moving label "gnd" from space to metal1 in cell FAX1.
Moving label "vdd" from space to metal1 in cell FAX1.
Moving label "A" from space to metal1 in cell FAX1.
Moving label "B" from space to metal1 in cell FAX1.
Moving label "C" from space to metal1 in cell FAX1.
Moving label "YC" from space to metal1 in cell FAX1.
Moving label "YS" from space to metal1 in cell FAX1.
Reading "HAX1".
Moving label "vdd" from space to metal1 in cell HAX1.
Moving label "gnd" from space to metal1 in cell HAX1.
Moving label "YC" from space to metal1 in cell HAX1.
Moving label "A" from space to metal1 in cell HAX1.
Moving label "B" from space to metal1 in cell HAX1.
Moving label "YS" from space to metal1 in cell HAX1.
Reading "INVX1".
Moving label "A" from space to metal1 in cell INVX1.
Moving label "Y" from space to metal1 in cell INVX1.
Moving label "vdd" from space to metal1 in cell INVX1.
Moving label "gnd" from space to metal1 in cell INVX1.
Reading "INVX2".
Moving label "vdd" from space to metal1 in cell INVX2.
Moving label "gnd" from space to metal1 in cell INVX2.
Moving label "Y" from space to metal1 in cell INVX2.
Moving label "A" from space to metal1 in cell INVX2.
Reading "INVX4".
Moving label "vdd" from space to metal1 in cell INVX4.
Moving label "gnd" from space to metal1 in cell INVX4.
Moving label "Y" from space to metal1 in cell INVX4.
Moving label "A" from space to metal1 in cell INVX4.
Reading "INVX8".
Moving label "vdd" from space to metal1 in cell INVX8.
Moving label "gnd" from space to metal1 in cell INVX8.
Moving label "A" from space to metal1 in cell INVX8.
Moving label "Y" from space to metal1 in cell INVX8.
Reading "NAND2X1".
Moving label "vdd" from space to metal1 in cell NAND2X1.
Moving label "Y" from space to metal1 in cell NAND2X1.
Moving label "gnd" from space to metal1 in cell NAND2X1.
Moving label "A" from space to metal1 in cell NAND2X1.
Moving label "B" from space to metal1 in cell NAND2X1.
Reading "NAND3X1".
Moving label "B" from space to metal1 in cell NAND3X1.
Moving label "vdd" from space to metal1 in cell NAND3X1.
Moving label "gnd" from space to metal1 in cell NAND3X1.
Moving label "A" from space to metal1 in cell NAND3X1.
Moving label "C" from space to metal1 in cell NAND3X1.
Moving label "Y" from space to metal1 in cell NAND3X1.
Reading "NOR2X1".
Moving label "vdd" from space to metal1 in cell NOR2X1.
Moving label "B" from space to metal1 in cell NOR2X1.
Moving label "gnd" from space to metal1 in cell NOR2X1.
Moving label "Y" from space to metal1 in cell NOR2X1.
Moving label "A" from space to metal1 in cell NOR2X1.
Reading "OAI21X1".
Moving label "gnd" from space to metal1 in cell OAI21X1.
Moving label "vdd" from space to metal1 in cell OAI21X1.
Moving label "A" from space to metal1 in cell OAI21X1.
Moving label "B" from space to metal1 in cell OAI21X1.
Moving label "Y" from space to metal1 in cell OAI21X1.
Moving label "C" from space to metal1 in cell OAI21X1.
Reading "OAI22X1".
Moving label "gnd" from space to metal1 in cell OAI22X1.
Moving label "vdd" from space to metal1 in cell OAI22X1.
Moving label "D" from space to metal1 in cell OAI22X1.
Moving label "C" from space to metal1 in cell OAI22X1.
Moving label "A" from space to metal1 in cell OAI22X1.
Moving label "B" from space to metal1 in cell OAI22X1.
Moving label "Y" from space to metal1 in cell OAI22X1.
Reading "OR2X1".
Moving label "Y" from space to metal1 in cell OR2X1.
Moving label "B" from space to metal1 in cell OR2X1.
Moving label "vdd" from space to metal1 in cell OR2X1.
Moving label "gnd" from space to metal1 in cell OR2X1.
Moving label "A" from space to metal1 in cell OR2X1.
Reading "OR2X2".
Moving label "Y" from space to metal1 in cell OR2X2.
Moving label "B" from space to metal1 in cell OR2X2.
Moving label "vdd" from space to metal1 in cell OR2X2.
Moving label "gnd" from space to metal1 in cell OR2X2.
Moving label "A" from space to metal1 in cell OR2X2.
Reading "TBUFX1".
Moving label "vdd" from space to metal1 in cell TBUFX1.
Moving label "gnd" from space to metal1 in cell TBUFX1.
Moving label "EN" from space to metal1 in cell TBUFX1.
Moving label "A" from space to metal1 in cell TBUFX1.
Moving label "Y" from space to metal1 in cell TBUFX1.
Reading "TBUFX2".
Moving label "vdd" from space to metal1 in cell TBUFX2.
Moving label "gnd" from space to metal1 in cell TBUFX2.
Moving label "A" from space to metal1 in cell TBUFX2.
Moving label "EN" from space to metal1 in cell TBUFX2.
Moving label "Y" from space to metal1 in cell TBUFX2.
Reading "XOR2X1".
Moving label "Y" from space to metal1 in cell XOR2X1.
Moving label "vdd" from space to metal1 in cell XOR2X1.
Moving label "B" from space to metal1 in cell XOR2X1.
Moving label "A" from space to metal1 in cell XOR2X1.
Moving label "gnd" from space to metal1 in cell XOR2X1.
Reading "MUX2X1".
Moving label "S" from space to metal1 in cell MUX2X1.
Moving label "vdd" from space to metal1 in cell MUX2X1.
Moving label "gnd" from space to metal1 in cell MUX2X1.
Moving label "Y" from space to metal1 in cell MUX2X1.
Moving label "A" from space to metal1 in cell MUX2X1.
Moving label "B" from space to metal1 in cell MUX2X1.
Reading "XNOR2X1".
Moving label "A" from space to metal1 in cell XNOR2X1.
Moving label "B" from space to metal1 in cell XNOR2X1.
Moving label "gnd" from space to metal1 in cell XNOR2X1.
Moving label "vdd" from space to metal1 in cell XNOR2X1.
Moving label "Y" from space to metal1 in cell XNOR2X1.
Reading "LATCH".
Moving label "D" from space to metal1 in cell LATCH.
Moving label "Q" from space to metal1 in cell LATCH.
Moving label "gnd" from space to metal1 in cell LATCH.
Moving label "vdd" from space to metal1 in cell LATCH.
Moving label "CLK" from space to metal1 in cell LATCH.
Reading "DFFSR".
Moving label "gnd" from space to metal1 in cell DFFSR.
Moving label "vdd" from space to metal1 in cell DFFSR.
Moving label "D" from space to metal1 in cell DFFSR.
Moving label "S" from space to metal1 in cell DFFSR.
Moving label "R" from space to metal1 in cell DFFSR.
Moving label "Q" from space to metal1 in cell DFFSR.
Moving label "CLK" from space to metal1 in cell DFFSR.
Reading "CLKBUF1".
Moving label "A" from space to metal1 in cell CLKBUF1.
Moving label "vdd" from space to metal1 in cell CLKBUF1.
Moving label "gnd" from space to metal1 in cell CLKBUF1.
Moving label "Y" from space to metal1 in cell CLKBUF1.
Reading "CLKBUF2".
Moving label "vdd" from space to metal1 in cell CLKBUF2.
Moving label "gnd" from space to metal1 in cell CLKBUF2.
Moving label "A" from space to metal1 in cell CLKBUF2.
Moving label "Y" from space to metal1 in cell CLKBUF2.
Reading "CLKBUF3".
Moving label "gnd" from space to metal1 in cell CLKBUF3.
Moving label "vdd" from space to metal1 in cell CLKBUF3.
Moving label "A" from space to metal1 in cell CLKBUF3.
Moving label "Y" from space to metal1 in cell CLKBUF3.
Reading "iit_stdcells".
aluuu: 10000 rects
aluuu: 20000 rects
aluuu: 30000 rects
aluuu: 40000 rects
aluuu: 50000 rects
Processing timestamp mismatches: FILL, BUFX2, AND2X2, NOR2X1, OR2X2, NAND3X1, INVX1, OAI21X1, NOR3X1, OAI22X1, NAND2X1, AOI21X1, AOI22X1, XNOR2X1.
Writing cell aluuu
Writing cell AND2X2
Writing cell NOR2X1
Writing cell OR2X2
Writing cell FILL
Writing cell BUFX2
Writing cell INVX1
Writing cell OAI21X1
Writing cell NAND2X1
Writing cell AOI21X1
Writing cell XNOR2X1
Writing cell NAND3X1
Writing cell AOI22X1
Writing cell OAI22X1
Writing cell NOR3X1
